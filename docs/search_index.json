[
["index.html", "Apprendre à programmer avec R Chapitre 1 Préface", " Apprendre à programmer avec R asardell 2021-05-02 Chapitre 1 Préface Ce livre permet de mettre un pied dans le monde de la programmation statistique avec le langage R. Il présente les concepts fondamentaux. Certaines parties sont extraites d’autres sources qui seront renseignées. Il n’y a pas de pré-requis pour suivre ce livre. Seulement une apétence pour la programmation et les analyses statistiques. Le code source de ce cours est disponible sur github. "],
["presentation.html", "Chapitre 2 Présentation 2.1 Introduction 2.2 Prise en main 2.3 Fonctions de tests et comparaisons 2.4 Regrouper ses commandes dans des scripts 2.5 Installer et charger des extensions (packages) 2.6 Exercices 2.7 Testez vos connaissances !", " Chapitre 2 Présentation Certaines parties de ce chapitre sont extraites du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) 2.1 Introduction 2.1.1 À propos de R R est un langage orienté vers le traitement et l’analyse quantitative des données, dérivé du langage. Il est développé depuis les années 90 par un groupe de volontaires de différents pays et par une grande communauté d’utilisateurs. C’est un logiciel libre, publié sous licence GNU GPL. Utilisation de R présente plusieurs avantages: c’est un logiciel multiplateforme, qui fonctionne aussi bien sur des systèmes Linux, Mac OS X ou Windows. c’est un logiciel libre, développé par ses utilisateurs, diffusable et modifiable par tout un chacun. c’est un logiciel gratuit. c’est un logiciel très puissant, dont les fonctionnalités de base peuvent être étendues à l’aide d’extensions développées par la communauté. Il en existe plusieurs milliers. c’est un logiciel dont le développement est très actif et dont la communauté d’utilisateurs et l’utilisation ne cessent de grandir. c’est un logiciel avec des capacités graphiques intéressantes. Comme rien n’est parfait, on peut également trouver quelques inconvénients : le logiciel, la documentation de référence et les principales ressources sont en anglais. Il est cependant parfaitement possible d’utiliser R sans spécialement maîtriser cette langue et il existe de plus en plus de ressources francophones. R n’est pas un logiciel au sens classique du terme, mais plutôt un langage de programmation. Il fonctionne à l’aide de scripts (des petits programmes) édités et exécutés au fur et à mesure de l’analyse. en tant que langage de programmation, R à la réputation d’être difficile d’accès, notamment pour ceux qui n’ont jamais été programmés auparavant. Au départ cantonné à la sphère universitaire, R est aujourd’hui de plus en plus utilisé dans des grandes entreprises et administrations, car il coûte beaucoup moins cher que ses concurrents (par exemple SAS) tout en étant très peformant. Ce document ne demande aucun prérequis en informatique ou en programmation. Juste un peu de motivation pour l’apprentissage du langage et, si possible, des données intéressantes sur l’application appliquée les connaissances acquiert. L’aspect langage de programmation et la difficulté qui en découle peut sembler des inconvénients importants. Le fait de structurer ses analyses sous forme de scripts (suite d’instructions effectuant les différentes opérations d’une analyse) présente cependant de nombreux avantages : le script garde par ordre chronologique l’ensemble des étapes d’une analyse, des données des données à leur analyser en passant par les manipulations et les recodages. on peut à tout moment revenir en arrière et modifier ce qui a été fait. il est très rapide de réexécuter une suite d’opérations complexes. on peut très facilement mettre à jour les résultats en cas de modification des sources de données. le script garanti, sous certaines conditions, la reproductibilité des résultats obtenus. 2.1.2 À propos de RStudio RStudio n’est pas à proprement parler une interface graphique pour R, il s’agit plutôt d’un environnement de développement intégré, qui propose des outils et facilite l’écriture de scripts et l’usage de R au quotidien. C’est une interface bien supérieure à celles fournies par défaut fournies installe R sous Windows ou sous Mac ^ [Sous Linux R n’est fourni que comme un outil en ligne de commande.]. Pour paraphraser Hadrien Commenges, il n’y a pas d’obligation à utiliser RStudio, mais il y a une obligation à ne pas utiliser les interfaces de R par défaut. RStudio est également un logiciel libre et gratuit. Une version payante existe, mais elle ne propose pas de fonctionnalités indispensables. 2.1.3 À propos du tidyverse Le tidyverse est un ensemble d’extensions pour R (code développé par la communauté permettant de rajouter des fonctionnalités à R) construites autour d’une philosophie commune et exercé pour fonctionner ensemble. Elles facilitent l’utilisation de R dans les domaines les plus courants : manipulation des données, recodages, production de graphiques, etc. 2.1.4 Structure du document Ce document est composé de deux grandes fêtes : Une Introduction à R , qui présente les bases du langage R et de l’interface RStudio Une Introduction au tidyverse qui présente cet ensemble d’extensions pour la visualisation, la manipulation des données et l’export de résultats 2.1.5 Prérequis Le seul prérequis pour suivre ce document est installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour l’installateur R, il suffit de se rendre sur une des pages suivantes : Installer R sous Windows Installateur R sous Mac Pour l’installateur RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système https://www.rstudio.com/products/rstudio/download/#download 2.2 Prise en main Une fois R et RStudio installés sur votre machine, nous n’allons pas lancer R mais plutôt RStudio. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts. 2.2.1 La console 2.2.1.1 L’invite de commandes Au premier lancement de RStudio, l’écran principal est découpé en trois grandes zones : La zone de gauche se nomme Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui. La Console doit normalement afficher un texte de bienvenue ressemblant à ceci : R version 3.5.2 (2018-12-20) -- &quot;Eggshell Igloo&quot; Copyright (C) 2018 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R est un logiciel libre livré sans AUCUNE GARANTIE. Vous pouvez le redistribuer sous certaines conditions. Tapez &#39;license()&#39; ou &#39;licence()&#39; pour plus de détails. R est un projet collaboratif avec de nombreux contributeurs. Tapez &#39;contributors()&#39; pour plus d&#39;information et &#39;citation()&#39; pour la façon de le citer dans les publications. Tapez &#39;demo()&#39; pour des démonstrations, &#39;help()&#39; pour l&#39;aide en ligne ou &#39;help.start()&#39; pour obtenir l&#39;aide au format HTML. Tapez &#39;q()&#39; pour quitter R. suivi d’une ligne commençant par le caractère &gt; et sur laquelle devrait se trouver votre curseur. Cette ligne est appelée l’invite de commande (ou prompt en anglais). Elle signifie que R est disponible et en attente de votre prochaine commande. Nous pouvons tout de suite lui fournir une première commande, en saisissant le texte suivant puis en appuyant sur Entrée : 2 + 2 ## [1] 4 R nous répond immédiatement, et nous pouvons constater avec soulagement qu’il sait faire des additions à un chiffre1. On peut donc continuer avec d’autres opérations : 5 - 7 ## [1] -2 4 * 12 ## [1] 48 -10 / 3 ## [1] -3.333333 5^2 ## [1] 25 Cette dernière opération utilise le symbole ^ qui représente l’opération puissance. 5^2 signifie donc “5 au carré”, soit 25. 2.2.1.2 Précisions concernant la saisie des commandes Lorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code. 10+2 10 + 2 10 + 2 Quand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut et vers le bas pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée. Enfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe + : 4 * + Cela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap. 2.2.2 Objets 2.2.2.1 Objets simples Faire des calculs c’est bien, mais il serait intéressant de pouvoir stocker un résultat quelque part pour pouvoir le réutiliser ultérieurement sans avoir à faire du copier/coller. Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche. Prenons tout de suite un exemple : x &lt;- 2 Cette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”. Si on exécute une commande comportant juste le nom d’un objet, R affiche son contenu : x ## [1] 2 On voit donc que notre objet x contient bien la valeur 2. On peut évidemment réutiliser cet objet dans d’autres opérations. R le remplacera alors par sa valeur : x + 4 ## [1] 6 On peut créer autant d’objets qu’on le souhaite. x &lt;- 2 y &lt;- 5 resultat &lt;- x + y resultat ## [1] 7 Attention Les noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat. De manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets. De même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite). Quand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire. x &lt;- 2 x &lt;- 5 x ## [1] 5 De la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche : x &lt;- 1 y &lt;- 3 x &lt;- y x ## [1] 3 ### Si on modifie y, cela ne modifie pas x y &lt;- 4 x ## [1] 3 On le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") : chien &lt;- &quot;Chihuahua&quot; chien ## [1] &quot;Chihuahua&quot; 2.2.2.2 Vecteurs Imaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien : taille1 &lt;- 156 taille2 &lt;- 164 taille3 &lt;- 197 taille4 &lt;- 147 taille5 &lt;- 173 (taille1 + taille2 + taille3 + taille4 + taille5) / 5 ## [1] 167.4 Cette manière de faire n’est évidemment pas pratique du tout. On va plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la fonction combine appeler avec le raccourci c : tailles &lt;- c(156, 164, 197, 147, 173) Si on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies : tailles ## [1] 156 164 197 147 173 Un vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre. L’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire : tailles_m &lt;- tailles / 100 tailles_m ## [1] 1.56 1.64 1.97 1.47 1.73 Cela fonctionne pour toutes les opérations de base : tailles + 10 ## [1] 166 174 207 157 183 tailles^2 ## [1] 24336 26896 38809 21609 29929 Imaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut alors créer un deuxième vecteur : poids &lt;- c(45, 59, 110, 44, 88) On peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré : imc &lt;- poids / (tailles / 100) ^ 2 imc ## [1] 18.49112 21.93635 28.34394 20.36189 29.40292 Un vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) diplome ## [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;CAP&quot; &quot;Bac+3&quot; L’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R : x &lt;- 1:10 x ## [1] 1 2 3 4 5 6 7 8 9 10 Enfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré. Par exemple : diplome[2] ## [1] &quot;Bac&quot; Cette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur. Dernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme : [1] 294 425 339 914 114 896 716 648 915 587 181 926 489 [14] 848 583 182 662 888 417 133 146 322 400 698 506 944 [27] 237 324 333 443 487 658 793 288 897 588 697 439 697 [40] 914 694 126 969 744 927 337 439 226 704 635 On remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc. Ceci explique le [1] qu’on obtient quand on affiche un simple nombre2 : [1] 4 On peut également effectuer une indexation multiple sur un vecteur si on souhaite sélectionner plusieurs élèments. diplome[c(2,3,4)] ## [1] &quot;Bac&quot; &quot;Bac+2&quot; &quot;CAP&quot; On peut également effectuer une indexation contraire sur un vecteur en précisant tous les élèments que l’on ne veut pas sélectionner. Pour cela, on utilise le ‘-’ devant l’indexation : diplome[-2] ## [1] &quot;CAP&quot; &quot;Bac+2&quot; &quot;CAP&quot; &quot;Bac+3&quot; diplome[- c(2,4)] ## [1] &quot;CAP&quot; &quot;Bac+2&quot; &quot;Bac+3&quot; 2.2.2.3 Type de vecteur Les vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent. On a ainsi des vecteurs de type numeric, character ou logical: numeric_vec &lt;- c(10,55,49,4) class(numeric_vec) ## [1] &quot;numeric&quot; character_vec &lt;- c(&quot;Jaune&quot;, &quot;Vert&quot;, &quot;Bleu&quot;, &quot;Rouge&quot;) class(character_vec) ## [1] &quot;character&quot; logical_vec &lt;- c(TRUE,FALSE,FALSE,TRUE) class(logical_vec) ## [1] &quot;logical&quot; Attention : dans un vecteur, tous les éléments sont de même type : un_vecteur &lt;- c(&quot;Luca&quot;, 30, 2000, FALSE) class(un_vecteur) ## [1] &quot;character&quot; un_vecteur ## [1] &quot;Luca&quot; &quot;30&quot; &quot;2000&quot; &quot;FALSE&quot; Il existe des fonctions pour tester la classe d’un vecteur. Elles s’écrivent avec le même préfixe is.classe_a_tester. Ces fonctions sont des tests logiques donc elles renvoient toujours des booléens. is.numeric(numeric_vec) ## [1] TRUE is.numeric(character_vec) ## [1] FALSE is.character(numeric_vec) ## [1] FALSE is.character(character_vec) ## [1] TRUE is.logical(logical_vec) ## [1] TRUE is.logical(character_vec) ## [1] FALSE Il est également possible de modifier la classe d’un vecteur avec les fonctions as.new_class. as.character(numeric_vec) ## [1] &quot;10&quot; &quot;55&quot; &quot;49&quot; &quot;4&quot; as.numeric(logical_vec) ## [1] 1 0 0 1 Dans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type character (des chaînes de caractères), ou bien des factor (facteurs). En R, la classe factor est un vecteur contenant uniquement certaines valeurs prédéfinies. Ces valeurs pré-définies sont appelées des levels. diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) class(diplome) ## [1] &quot;character&quot; diplome &lt;- as.factor(diplome) diplome ## [1] CAP Bac Bac+2 CAP Bac+3 ## Levels: Bac Bac+2 Bac+3 CAP class(diplome) ## [1] &quot;factor&quot; Si on souhaite modifier ou ajouter un élèment avec une modalité qui n’est pas pris en compte dans les levels, nous allons avoir une erreur. diplome[6] &lt;- &quot;Master&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 6, value = &quot;Master&quot;): invalid factor ## level, NA generated diplome ## [1] CAP Bac Bac+2 CAP Bac+3 &lt;NA&gt; ## Levels: Bac Bac+2 Bac+3 CAP Il faut donc modifier les levels acceptés par le vecteur en amont. levels(diplome) &lt;- c(levels(diplome), &quot;Master&quot;) diplome[6] &lt;- &quot;Master&quot; diplome ## [1] CAP Bac Bac+2 CAP Bac+3 Master ## Levels: Bac Bac+2 Bac+3 CAP Master Mais à quoi peut servir tout cela ? En réalité, l’intérêt principal de la classe factor est de prendre moins de place en mémoire car les levels sont stockés en numeric. Si on transforme notre vecteur en classe numeric nous n’allons pas avoir d’erreur. class(diplome) ## [1] &quot;factor&quot; diplome &lt;- as.numeric(diplome) class(diplome) ## [1] &quot;numeric&quot; diplome ## [1] 4 1 2 4 3 5 On observe que les nombres obtenus correspondent aux numéros de levels. Il faut donc faire trés attention lorsqu’on veut passer une classe numeric à une variable quantitative importée en tant que factor. 2.2.3 Fonctions 2.2.3.1 Principe Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard. Pour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions. Formellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat. Prenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière : length(tailles) ## [1] 5 Ici, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre. Autre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres : min(tailles) ## [1] 147 max(tailles) ## [1] 197 La fonction mean calcule et retourne la moyenne d’un vecteur de nombres : mean(tailles) ## [1] 167.4 La fonction sum retourne la somme de tous les éléments du vecteur : sum(tailles) ## [1] 837 Jusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum : range(tailles) ## [1] 147 197 Ou encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) unique(diplome) ## [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;Bac+3&quot; 2.2.3.2 Arguments Une fonction peut prendre plusieurs arguments, dans ce cas on les indique toujours entre parenthèses, séparés par des virgules. On a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur3 : tailles &lt;- c(156, 164, 197, 181, 173) Ici, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs. Supposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre). On symbolise celle-ci dans R avec le code interne NA : tailles &lt;- c(156, 164, 197, NA, 173) tailles ## [1] 156 164 197 NA 173 NA est l’abréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc. Si je calcule maintenant la taille moyenne à l’aide de la fonction mean, j’obtiens : mean(tailles) ## [1] NA En effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Il considère alors que cette moyenne est elle-même “non disponible” et renvoie donc comme résultat NA. On peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai) : mean(tailles, na.rm = TRUE) ## [1] 172.5 Positionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul. Si on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes : mean(tailles) ## [1] NA mean(tailles, na.rm = FALSE) ## [1] NA Lorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé. 2.2.3.3 Aide sur une fonction Il est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help : help(&quot;mean&quot;) ?mean On peut aussi utiliser le raccourci ?mean. Ces deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée. Dans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide. 2.2.3.4 Programmer des fonctions Il est possible de programmer ses propres fonctions. Dans l’exemple ci-dessous on construit une fonction imcq ui prend en entrée deux arguments poids et taille. La fonction effectue un calcul et renvoi l’IMC. Pour construire une fonction, on doit obligatoirement faire appel au mot clé function. Le mot clé return n’est pas obligatoire. Cependant, par convention, une fonction renvoie toujours un résultat qui peut aussi être un message d’information sur le bon déroulement de celle-ci. Les arguments sont précisés entre parenthèses ( ). Les traitements s’effectuent entre accolades { }. imc &lt;- function(taille,poids) { calcul &lt;- poids / (taille^2) return (calcul) } Lorsqu’on vérifie la classe de l’objet imc en mémoire, on constate qu’il est bien de type function. class(imc) ## [1] &quot;function&quot; Puis c’est le même principe que les autres fonctions pour l’utiliser : imc(taille = 1.55, poids = 49) ## [1] 20.39542 Il est possible de préciser des arguments par défaut. Ils sont à saisir dans la définition des arguments : imc &lt;- function(taille = 1.70, poids = 60) { calcul &lt;- poids / (taille^2) return (calcul) } imc() ## [1] 20.76125 2.3 Fonctions de tests et comparaisons Dans R, il est possible d’effectuer des comparaisons ou des tests qui vont retourner la valeur TRUE si vrai et FALSE si faux 2.3.1 Opérateurs de comparaisons Voici les différents opérateurs de comparaisons que l’on peut utiliser : a &lt;- c(1,3,5,9) b &lt;- c(1,2,6,9) a &gt; b ## [1] FALSE TRUE FALSE FALSE a == b ## [1] TRUE FALSE FALSE TRUE a != b ## [1] FALSE TRUE TRUE FALSE 2.3.2 Opérateurs logiques Ces opérateurs permettent de tester l’effet de plusieurs tests logiques. a &lt;- c(1,3,5,9) b &lt;- c(1,2,6,9) (a &gt; b) &amp; ( a &gt; 4) ## [1] FALSE FALSE FALSE FALSE (a == b) | (a &gt; 4) ## [1] TRUE FALSE TRUE TRUE xor(a &gt; b, a &gt; 4) ## [1] FALSE TRUE TRUE TRUE a &gt; b ## [1] FALSE TRUE FALSE FALSE ! a &gt; b ## [1] TRUE FALSE TRUE TRUE 2.3.3 Fonctions logiques Il existe des fonctions pour effectuer des tests logiques. Elles ont toutes le même préfixe et s’écrivent is.mon_test. On peut par exemple tester la classe d’un objet avec les fonctions is.classe_a_tester. Ces fonctions sont des tests logiques donc elles renvoient toujours des booléens (rappel TD1). numeric_vec &lt;- c(10,55,49,4) class(numeric_vec) ## [1] &quot;numeric&quot; character_vec &lt;- c(&quot;Jaune&quot;, &quot;Vert&quot;, &quot;Bleu&quot;, &quot;Rouge&quot;) class(character_vec) ## [1] &quot;character&quot; is.numeric(numeric_vec) ## [1] TRUE is.numeric(character_vec) ## [1] FALSE is.character(numeric_vec) ## [1] FALSE is.character(character_vec) ## [1] TRUE On peut aussi tester la présence FALSE/ TRUE de valeurs manquantes NA avec la fonction is.na. a &lt;- c(1,NA,6,9) is.na(a) ## [1] FALSE TRUE FALSE FALSE 2.4 Regrouper ses commandes dans des scripts Jusqu’ici on a utilisé R de manière “interactive”, en saisissant des commandes directement dans la console. Ça n’est cependant pas la manière dont on va utiliser R au quotidien, pour une raison simple : lorsque R redémarre, tout ce qui a été effectué dans la console est perdu. Plutôt que de saisir nos commandes dans la console, on va donc les regrouper dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” les données, leur traitement, les analyses et leurs résultats. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script. Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choisissant File puis Save. Un script est un fichier texte brut, qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne (comme on pouvait s’y attendre). Pour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup. Finalement, un script pourra ressembler à quelque chose comme ça : tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) mean(tailles) mean(poids) imc &lt;- poids / (tailles / 100) ^ 2 min(imc) max(imc) 2.4.1 Commentaires Les commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption. Pour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne. On peut donc documenter le script précédent : # Saisie des tailles et poids des enquêtés tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) # Calcul des tailles et poids moyens mean(tailles) mean(poids) # Calcul de l&#39;IMC (poids en kilo divisé par les tailles en mètre au carré) imc &lt;- poids / (tailles / 100) ^ 2 # Valeurs extrêmes de l&#39;IMC min(imc) max(imc) 2.5 Installer et charger des extensions (packages) R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network). Pour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install. On peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande : install.packages(&quot;questionr&quot;) Installer une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC. Cela suppose que vous disposez d’une connexion internet. Cependant, il est possible d’installer des packages en local sans connexion internet sous réserve d’être en possession des packages en fichiers zippés. Une fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante : library(questionr) Ainsi, bien souvent, on regroupe en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme : library(readxl) library(ggplot2) library(questionr) Si vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante. 2.6 Exercices 2.6.1 Sujet Exercice 1 Construire le vecteur x suivant : ## [1] 120 134 256 12 Utiliser ce vecteur x pour générer les deux vecteurs suivants : ## [1] 220 234 356 112 ## [1] 240 268 512 24 Exercice 2 On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. Exercice 3 Dans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint. conjoint1 &lt;- c(1200, 1180, 1750, 2100) Recommencer avec les revenus suivants, parmi lesquels l’un des enquêtés n’a pas voulu répondre : conjoint1 &lt;- c(1200, 1180, 1750, NA) Exercice 4 Les deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes sur la ville de Lyon, pour chaque mois de l’année, entre 1981 et 2010 : temperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4) precipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2) Calculer la température moyenne sur l’année. Calculer la quantité totale de précipitations sur l’année. À quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire. cumsum(precipitations) ## [1] 47.2 91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 ## [12] 831.9 Même question pour : diff(temperature) ## [1] 1.4 3.6 3.0 4.4 3.6 2.8 -0.6 -4.0 -4.2 -5.8 -3.2 Exercice 5 On a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs : maths &lt;- c(12, 16, 8, 18, 6, 10) anglais &lt;- c(14, 9, 13, 15, 17, 11) sport &lt;- c(18, 11, 14, 10, 8, 12) Calculer la moyenne des élèves de la classe en anglais. Calculer la moyenne générale de chaque élève. Essayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) : pmin(maths, anglais, sport) ## [1] 12 9 8 10 6 10 pmax(maths, anglais, sport) ## [1] 18 16 14 18 17 12 2.6.2 Correction Exercice 1 Construire le vecteur x suivant : ## [1] 120 134 256 12 x &lt;- c(120, 134, 256, 12) Utiliser ce vecteur x pour générer les deux vecteurs suivants : ## [1] 220 234 356 112 ## [1] 240 268 512 24 x + 100 x * 2 Exercice 2 On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. revenu_total &lt;- conjoint1 + conjoint2 revenu_total / nb_personnes Exercice 3 Dans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint. conjoint1 &lt;- c(1200, 1180, 1750, 2100) range(conjoint1) Recommencer avec les revenus suivants, parmi lesquels l’un des enquêtés n’a pas voulu répondre : conjoint1 &lt;- c(1200, 1180, 1750, NA) range(conjoint1, na.rm = TRUE) Exercice 4 Les deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes sur la ville de Lyon, pour chaque mois de l’année, entre 1981 et 2010 : temperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4) precipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2) Calculer la température moyenne sur l’année. mean(temperature) Calculer la quantité totale de précipitations sur l’année. sum(precipitations) À quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire. cumsum(precipitations) ## [1] 47.2 91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 ## [12] 831.9 Même question pour : diff(temperature) ## [1] 1.4 3.6 3.0 4.4 3.6 2.8 -0.6 -4.0 -4.2 -5.8 -3.2 cumsum(precipitations) correspond à la somme cumulée des précipitations sur l’année. Par exemple, la 6e valeur du vecteur résultat correspond au total de précipitations de janvier à juin. diff(temperature) correspond à la différence de température d’un mois sur l’autre. Par exemple, la 2e valeur de ce vecteur correspond à l’écart de température entre le mois de février et le mois de janvier. Exercice 5 On a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs : maths &lt;- c(12, 16, 8, 18, 6, 10) anglais &lt;- c(14, 9, 13, 15, 17, 11) sport &lt;- c(18, 11, 14, 10, 8, 12) Calculer la moyenne des élèves de la classe en anglais. mean(anglais) Calculer la moyenne générale de chaque élève. (maths + anglais + sport) / 3 Essayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) : pmin(maths, anglais, sport) ## [1] 12 9 8 10 6 10 pmax(maths, anglais, sport) ## [1] 18 16 14 18 17 12 pmin et pmax renvoient les minimum et maximum “parallèles” des trois vecteurs passés en argument. Ainsi, pmin renvoie pour chaque élève la note minimale dans les trois matières, et pmax la note maximale. 2.7 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. On peut ignorer pour le moment la présence du [1] en début de ligne.↩︎ Et permet de constater que pour R, un nombre est un vecteur à un seul élément.↩︎ c est l’abréviation de combine, son nom est très court car on l’utilise très souvent↩︎ "],
["first-dataset.html", "Chapitre 3 Premier travail avec des données 3.1 Jeu de données d’exemple 3.2 Tableau de données (data frame) 3.3 Analyse univariée 3.4 Combiner plusieurs variables 3.5 Exercices 3.6 Testez vos connaissances !", " Chapitre 3 Premier travail avec des données Certaines parties de ce chapitre sont extraites du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) 3.1 Jeu de données d’exemple Dans cette partie nous allons (enfin) travailler sur des “vraies” données, et utiliser un jeu de données présent dans l’extension questionr. Nous devons donc avant toute chose installer cette extension. Pour installer ce package, deux possibilités : Dans l’onglet Packages de la zone de l’écran en bas à droite, cliquez sur le bouton Install. Dans le dialogue qui s’ouvre, entrez “questionr” dans le champ Packages puis cliquez sur Install. Saisissez directement la commande suivante dans la console : install.packages(\"questionr\") Dans les deux cas, tout un tas de messages devraient s’afficher dans la console. Attendez que l’invite de commandes &gt; apparaisse à nouveau. Le jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) : library(questionr) L’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension. Nous devons ensuite indiquer à R que nous souhaitons accéder au jeu de données à l’aide de la commande data : data(hdv2003) Cette commande ne renvoie aucun résultat particulier (sauf en cas d’erreur), mais vous devriez voir apparaître dans l’onglet Environment de RStudio un nouvel objet nommé hdv2003 : Cet objet est d’un type nouveau : il s’agit d’un tableau de données. 3.2 Tableau de données (data frame) Un data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel. Si on se contente d’exécuter le nom de notre tableau de données : hdv2003 R va, comme à son habitude, nous l’afficher dans la console, ce qui est tout sauf utile. Une autre manière d’afficher le contenu du tableau est de cliquer sur l’icône en forme de tableau à droite du nom de l’objet dans l’onglet Environment : Ou d’utiliser la fonction View : View(x = hdv2003) Dans les deux cas votre tableau devrait s’afficher dans RStudio avec une interface de type tableur : Il est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille4. Sous R, on peut importer ou créer autant de tableaux de données qu’on le souhaite, dans les limites des capacités de sa machine. Un data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire : d &lt;- hdv2003 ce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite. Pour résumer, comme nous avons désormais décidé de saisir nos commandes dans un script et non plus directement dans la console, les premières lignes de notre fichier de travail sur les données de l’enquête Histoire de vie pourraient donc ressembler à ceci : ## Chargement des extensions nécessaires library(questionr) ## Jeu de données hdv2003 data(hdv2003) d &lt;- hdv2003 3.2.1 Structure du tableau Un tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau : nrow(x = d) ## [1] 2000 ncol(x = d) ## [1] 20 La fonction dim renvoie ses dimensions, donc les deux nombres précédents : dim(x = d) ## [1] 2000 20 La fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables : names(x = d) ## [1] &quot;id&quot; &quot;age&quot; &quot;sexe&quot; &quot;nivetud&quot; ## [5] &quot;poids&quot; &quot;occup&quot; &quot;qualif&quot; &quot;freres.soeurs&quot; ## [9] &quot;clso&quot; &quot;relig&quot; &quot;trav.imp&quot; &quot;trav.satisf&quot; ## [13] &quot;hard.rock&quot; &quot;lecture.bd&quot; &quot;peche.chasse&quot; &quot;cuisine&quot; ## [17] &quot;bricol&quot; &quot;cinema&quot; &quot;sport&quot; &quot;heures.tv&quot; On peut aussi utiliser la fonction colnames : colnames(x = d) ## [1] &quot;id&quot; &quot;age&quot; &quot;sexe&quot; &quot;nivetud&quot; ## [5] &quot;poids&quot; &quot;occup&quot; &quot;qualif&quot; &quot;freres.soeurs&quot; ## [9] &quot;clso&quot; &quot;relig&quot; &quot;trav.imp&quot; &quot;trav.satisf&quot; ## [13] &quot;hard.rock&quot; &quot;lecture.bd&quot; &quot;peche.chasse&quot; &quot;cuisine&quot; ## [17] &quot;bricol&quot; &quot;cinema&quot; &quot;sport&quot; &quot;heures.tv&quot; Enfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type 5 et affiche les premières valeurs : str(object = d) ## &#39;data.frame&#39;: 2000 obs. of 20 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ age : int 28 23 59 34 71 35 60 47 20 28 ... ## $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 2 2 1 1 2 2 2 1 2 1 ... ## $ nivetud : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA 3 8 3 6 3 6 NA 7 ... ## $ poids : num 2634 9738 3994 5732 4329 ... ## $ occup : Factor w/ 7 levels &quot;Exerce une profession&quot;,..: 1 3 1 1 4 1 6 1 3 1 ... ## $ qualif : Factor w/ 7 levels &quot;Ouvrier specialise&quot;,..: 6 NA 3 3 6 6 2 2 NA 7 ... ## $ freres.soeurs: int 8 2 2 1 0 5 1 5 4 2 ... ## $ clso : Factor w/ 3 levels &quot;Oui&quot;,&quot;Non&quot;,&quot;Ne sait pas&quot;: 1 1 2 2 1 2 1 2 1 2 ... ## $ relig : Factor w/ 6 levels &quot;Pratiquant regulier&quot;,..: 4 4 4 3 1 4 3 4 3 2 ... ## $ trav.imp : Factor w/ 4 levels &quot;Le plus important&quot;,..: 4 NA 2 3 NA 1 NA 4 NA 3 ... ## $ trav.satisf : Factor w/ 3 levels &quot;Satisfaction&quot;,..: 2 NA 3 1 NA 3 NA 2 NA 1 ... ## $ hard.rock : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ lecture.bd : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ peche.chasse : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 2 2 1 1 ... ## $ cuisine : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1 1 2 1 1 2 2 1 1 ... ## $ bricol : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 2 1 1 1 2 1 1 ... ## $ cinema : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 1 2 1 2 1 1 2 2 ... ## $ sport : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 2 2 1 2 1 1 1 2 ... ## $ heures.tv : num 0 1 0 2 3 2 2.9 1 2 2 ... Sous RStudio, on peut afficher à tout moment la structure d’un objet en cliquant sur l’icône de triangle sur fond bleu à gauche du nom de l’objet dans l’onglet Environment : 3.2.2 Accéder aux variables d’un tableau Une opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape : d$sexe ## [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme ## [12] Homme Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme ## [23] Femme Femme Femme Homme Femme Homme Homme Homme Homme Homme Homme ## [34] Homme Femme Femme Homme Femme Femme Homme Femme Homme Homme Femme ## [45] Femme Homme Femme Femme Femme Femme Homme Femme Homme Femme Homme ## [56] Femme Femme Femme Homme Femme Femme Homme Homme Homme Homme Femme ## [67] Homme Homme Femme Femme Homme Homme Femme Femme Femme Femme Homme ## [78] Femme Femme Femme Femme Femme Femme Homme Homme Femme Homme Homme ## [89] Homme Homme Homme Femme Homme Femme Femme Femme Homme Homme Femme ## [100] Femme Femme Homme Femme Homme Homme Femme Femme Femme Femme Homme ## [111] Homme Homme Homme Homme Femme Homme Homme Femme Homme Homme Femme ## [122] Femme Femme Homme Femme Femme Homme Femme Femme Homme Femme Homme ## [133] Femme Femme Femme Homme Homme Homme Homme Homme Homme Homme Homme ## [144] Femme Homme Homme Homme Femme Femme Femme Homme Femme Femme Femme ## [155] Femme Homme Femme Homme Homme Homme Femme Homme Femme Homme Femme ## [166] Homme Homme Femme Femme Femme Homme Femme Homme Femme Femme Femme ## [177] Homme Homme Homme Femme Homme Femme Femme Homme Homme Femme Femme ## [188] Femme Femme Femme Homme Homme Femme Homme Homme Femme Homme Femme ## [199] Homme Femme ## [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] ## Levels: Homme Femme R va nous afficher l’ensemble des valeurs de notre variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment. Pour le moment, on ne fait pas attention à Levels: Homme Femme La fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères. Si on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail : head(x = d$age) ## [1] 28 23 59 34 71 35 tail(x = d$age, 10) ## [1] 52 42 50 41 46 45 46 24 24 66 Le deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher. 3.2.3 Créer une nouvelle variable On peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur. Par exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé : head(x = d$heures.tv, n = 10) ## [1] 0.0 1.0 0.0 2.0 3.0 2.0 2.9 1.0 2.0 2.0 On peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée mais en minutes. On va donc créer une nouvelle variable minutes.tv de la manière suivante : d$minutes.tv &lt;- d$heures.tv * 60 On peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau : head(x = d$minutes.tv) ## [1] 0 60 0 120 180 120 On peut également supprimer une colonne d’un data frame en utilisant &lt;- NULL #création d&#39;une colonne temporaire d$temp &lt;- NA #vérification de la création de la colonne d$temp ## [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [24] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [47] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [70] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [93] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [116] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [139] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [162] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [185] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] #nombre de colonne avant la suppression ncol(x = d) ## [1] 22 #suppression de la colonne d$temp &lt;- NULL #nombre de colonne après la suppression ncol(x = d) ## [1] 21 3.3 Analyse univariée On a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $. Si on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : le sexe, la profession, le dernier diplôme obtenu, etc.). 3.3.1 Analyser une variable quantitative Une variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv). 3.3.1.1 Indicateurs de position Caractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent. Pour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range : min(x = d$age) ## [1] 18 max(x = d$age) ## [1] 97 range(x = d$age) ## [1] 18 97 On peut aussi calculer des indicateurs de position : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean : mean(x = d$age) ## [1] 48.157 Il existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median : median(x = d$age) ## [1] 48 Une différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2013, le salaire net moyen des salariés à temps plein en France était de 2202 euros, tandis que le salaire net médian n’était que de 1772 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut. 3.3.1.2 Indicateurs de dispersion Les indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées. L’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations : max(d$age) - min(d$age) ## [1] 79 Les indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abréviation de standard deviation) : var(x = d$age) ## [1] 287.0249 sd(x = d$age) ## [1] 16.94181 Plus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées. Une autre manière de mesurer la dispersion est de calculer les quartiles : le premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au-dessus le deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au-dessus (c’est donc la médiane) le troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au-dessus On peut les calculer avec la fonction quantile : ## Premier quartile quantile(x = d$age, probs = 0.25) ## 25% ## 35 ## Troisième quartile quantile(x = d$age, probs = 0.75) ## 75% ## 60 L’argument quantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc. Par défaut, la fonction quantile affiche le min, max et les quartiles de la série : quantile(x = d$age) ## 0% 25% 50% 75% 100% ## 18 35 48 60 97 Attention ! L’ensemble les fonctions statistiques sont sensibles à la présence de valeurs manquantes NA. On utilisera l’argument na.rm = TRUE pour éviter les erreurs. Notons enfin que la fonction summary permet d’obtenir d’un coup plusieurs indicateurs classiques : summary(object = d$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 18.00 35.00 48.00 48.16 60.00 97.00 3.3.1.3 Représentation graphique L’outil le plus utile pour étudier la distribution des valeurs d’une variable quantitative reste la représentation graphique. La représentation la plus courante est sans doute l’histogramme. On peut l’obtenir avec la fonction hist : hist(x = d$age) Cette fonction n’a pas pour effet direct d’effectuer un calcul ou de nous renvoyer un résultat : elle génère un graphique qui va s’afficher dans l’onglet Plots de RStudio. On peut personnaliser l’apparence de l’histogramme en ajoutant des arguments supplémentaires à la fonction hist. L’argument le plus important est breaks, qui permet d’indiquer le nombre de classes que l’on souhaite. hist(x = d$age, breaks = 10) hist(x = d$age, breaks = 70) Le choix d’un “bon” nombre de classes pour un histogramme n’est pas un problème simple : si on a trop peu de classes, on risque d’effacer quasiment toutes les variations, et si on en a trop on risque d’avoir trop de détails et de masquer les grandes tendances. Les arguments de hist permettent également de modifier la présentation du graphique. On peut ainsi changer la couleur des barres avec col6, le titre avec main, les étiquettes des axes avec xlab et ylab, etc. : hist(x = d$age, col = &quot;skyblue&quot;, main = &quot;Répartition des ages des enquêtés&quot;, xlab = &quot;age&quot;, ylab = &quot;Effectif&quot;) La fonction hist fait partie des fonctions graphique de base de R. Elle est souvent associée au graphique boîtes à moustaches (boxplot) qui permet de résumer la distribution d’une variable quantitative à travers les quartiles notamment. boxplot(x = d$age, main = &quot;Distribution de l&#39;age&quot;) 3.3.2 Analyser une variable qualitative Une variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)… À noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs. 3.3.2.1 Tri à plat L’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table : table(x = d$sexe) ## x ## Homme Femme ## 899 1101 Ce tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes. table(x = d$qualif) ## x ## Ouvrier specialise Ouvrier qualifie Technicien ## 203 292 86 ## Profession intermediaire Cadre Employe ## 160 260 594 ## Autre ## 58 Un tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tri à plat selon la valeur de l’effectif. On peut donc faire : tab &lt;- table(x = d$qualif) sort(tab) ## x ## Autre Technicien Profession intermediaire ## 58 86 160 ## Ouvrier specialise Cadre Ouvrier qualifie ## 203 260 292 ## Employe ## 594 Attention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = \"always\", soit : table(d$qualif, useNA = \"always\"). À noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles : summary(object = d$qualif) ## Ouvrier specialise Ouvrier qualifie Technicien ## 203 292 86 ## Profession intermediaire Cadre Employe ## 160 260 594 ## Autre NA&#39;s ## 58 347 Par défaut ces tris à plat sont en effectifs et ne sont donc pas toujours très lisibles, notamment quand on a des effectifs importants. On leur rajoute donc en général la répartition en pourcentages. Pour cela, nous allons utiliser la fonction freq de l’extension questionr, qui devra donc avoir précédemment été chargée avec library(questionr) : ## À rajouter en haut de script et à exécuter library(questionr) On peut alors utiliser la fonction : freq(x = d$qualif) ## n % val% ## Ouvrier specialise 203 10.2 12.3 ## Ouvrier qualifie 292 14.6 17.7 ## Technicien 86 4.3 5.2 ## Profession intermediaire 160 8.0 9.7 ## Cadre 260 13.0 15.7 ## Employe 594 29.7 35.9 ## Autre 58 2.9 3.5 ## NA 347 17.3 NA La colonne n représente les effectifs de chaque catégorie, la colonne % le pourcentage, et la colonne val% le pourcentage calculé sur les valeurs valides, donc en excluant les NA. Une ligne a également été rajoutée pour indiquer le nombre et la proportion de NA. freq accepte un certain nombre d’arguments pour personnaliser son affichage. Par exemple : valid indique si on souhaite ou non afficher les pourcentages sur les valeurs valides cum indique si on souhaite ou non afficher les pourcentages cumulés total permet d’ajouter une ligne avec les effectifs totaux sort permet de trier le tableau par fréquence croissante (sort=\"inc\") ou décroissante (sort=\"dec\"). freq(x = d$qualif, valid = FALSE, total = TRUE, sort = &quot;dec&quot;) ## n % ## Employe 594 29.7 ## Ouvrier qualifie 292 14.6 ## Cadre 260 13.0 ## Ouvrier specialise 203 10.2 ## Profession intermediaire 160 8.0 ## Technicien 86 4.3 ## Autre 58 2.9 ## NA 347 17.3 ## Total 2000 100.0 3.3.2.2 Représentations graphiques On peut représenter graphiquement le tri à plat d’une variable qualitative avec un diagramme en barres, obtenu avec la fonction barplot. Attention, contrairement à hist cette fonction ne s’applique pas directement à la variable mais au résultat du tri à plat de cette variable, calculé avec table. Il faut donc procéder en deux étapes : tab &lt;- table( x = d$qualif ) barplot(height = tab, main = &#39;Répartition par qualification&#39;, las= 2, cex.names = 0.4) L’argument las permet de pivoter les étiquettes et cex.names la taille de la police. On peut aussi trier le tri à plat avec la fonction sort avant de le représenter graphiquement, ce qui peut faciliter la lecture du graphique : La fonction pie permet de construire un diagramme circulaire. Il fonctionne de la même manière que la fonction barplot. tab &lt;- table(x = d$sexe) pie(x = tab) 3.4 Combiner plusieurs variables 3.4.1 Créer une nouvelle variable On peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans un data frame : pour cela, il suffit de lui assigner une valeur. Par exemple dans le jeu de données hdv2003, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé. On peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée mais en minutes. On va donc créer une nouvelle variable minutes.tv de la manière suivante : #par convention on ne modifie jamais le fichier source d &lt;- hdv2003 d$minutes.tv &lt;- d$heures.tv * 60 3.4.2 Créer des regroupements de modalités Parfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. La fonction ifelse permet de construire des regroupements simples. Elle se construit comme la fonction si d’excel. help(&quot;ifelse&quot;) Toujours dans le jeu de données hdv2003, on souhaite créer une variable actif / inactif basée sur la variable occup telle que : occup Regroupement Exerce une profession actif Etudiant, eleve inactif Chomeur inactif Retraite inactif Retire des affaires inactif Au foyer inactif Autre inactif inactif d$occupGroup &lt;- ifelse(test = (d$occup == &quot;Exerce une profession&quot;), yes = &quot;actif&quot;, no = &quot;inactif&quot;) table(d$occupGroup) ## ## actif inactif ## 1049 951 Cependant, la population active regroupe la population active occupée (appelée aussi « population active ayant un emploi ») et les chômeurs. On opère donc un nouveau regroupement en plaçant cette fois-ci les chômeurs avec les actifs : d$occupGroup &lt;- ifelse(test = (d$occup == &quot;Exerce une profession&quot; | d$occup == &quot;Chomeur&quot;), yes = &quot;actif&quot;, no = &quot;inactif&quot;) table(d$occupGroup) ## ## actif inactif ## 1183 817 Lorsqu’on travaille sur la même variable et pour éviter l’utilisation de “OU” répétés, on utilise le mot clé %in%. d$occupGroup &lt;- ifelse(test = (d$occup %in% c(&quot;Exerce une profession&quot;,&quot;Chomeur&quot;)), yes = &quot;actif&quot;, no = &quot;inactif&quot;) table(d$occupGroup) ## ## actif inactif ## 1183 817 3.4.3 Découper une variable numérique en classes Une autre opération relativement courante consiste à découper une variable numérique en classes. Par exemple, on voudra transformer la variable âge avec des catégories : Moins de 30 euros, 30-50 ans, plus de 50 ans, etc. Pour cela, on utilise la fonction cut. help(&quot;cut&quot;) Si on donne un nombre entier à l’argument breaks, un nombre correspondant de classes d’amplitudes égales sont automatiquement calculées. Il est souvent préférable cependant d’avoir des limites “rondes”, on peut alors spécifier ces dernières manuellement en passant un vecteur à breaks : d$ageGroup &lt;- cut(x = d$age, breaks = c(min(d$age),30,50,max(d$age)) , include.lowest = TRUE) table(d$ageGroup) ## ## [18,30] (30,50] (50,97] ## 351 780 869 Ici on a été obligé d’ajouter l’argument include.lowest = TRUE car sinon la valeur 18 n’aurait pas été incluse, et on aurait eu des valeurs manquantes. 3.5 Exercices 3.5.1 Sujet Exercice 1 Créer un nouveau script qui effectue les actions suivantes : charger l’extension questionr charger le jeu de données nommé hdv2003 copier le jeu de données dans un nouvel objet nommé df afficher les dimensions et la liste des variables de df Exercice 2 On souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes. Exercice 3 On s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table. Faites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Y’a-t-il des valeurs manquantes ? Représentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres. Utilisez l’argument col de la fonction barplot pour modifier la couleur du graphique en tomato. 3.5.2 Correction Exercice 1 Créer un nouveau script qui effectue les actions suivantes : charger l’extension questionr library(questionr) charger le jeu de données nommé hdv2003 data(hdv2003) copier le jeu de données dans un nouvel objet nommé df df &lt;- hdv2003 afficher les dimensions et la liste des variables de df dim(x = df) names(x = df) Exercice 2 On souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes. summary(object = df$heures.tv) sd(x = df$heures.tv) hist(x = df$heures.tv, breaks = 10) Exercice 3 On s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table. table(x = df$trav.imp) Faites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Y’a-t-il des valeurs manquantes ? freq(x = df$trav.imp) Représentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres. tab &lt;- sort(x = table(x = df$trav.imp)) barplot(height = tab) Utilisez l’argument col de la fonction barplot pour modifier la couleur du graphique en tomato. barplot(height = tab, col = &quot;tomato&quot;) Tapez colors() dans la console pour afficher l’ensemble des noms de couleurs disponibles dans R. 3.6 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. La seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩︎ Les différents types de variables seront décrits plus en détail dans un autre TD sur les recodages.↩︎ Les différentes manières de spécifier des couleurs seront abordées plus tard.↩︎ "],
["first-import.html", "Chapitre 4 Importer des données externes 4.1 Import de fichiers csv 4.2 Interface interactive d’import de fichiers 4.3 Modifier le répertoire actif 4.4 Import depuis un fichier Excel 4.5 Export de données 4.6 Exercices 4.7 Testez vos connaissances !", " Chapitre 4 Importer des données externes Certaines parties de ce chapitre sont extraites du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) 4.1 Import de fichiers csv R n’est pas prévu pour la saisie de données, mais il bénéficie de nombreuses fonctions et packages permettant l’import de données depuis un grand nombre de formats. Seuls les plus courants seront abordés ici. Si votre fichier CSV suit un format CSV standard (c’est le cas s’il a été exporté depuis LibreOffice par exemple), avec des champs séparés par des virgules, vous pouvez utiliser la fonction read.csv en lui passant en argument le chemin et le nom du fichier. Cette fonction est issue du package utils chargé par défaut à chaque ouverture d’une session RStudio. dataset &lt;- read.csv(file = &quot;C:/Users/anthony.sardellitti/Programmation_Statistique_R/dataset/Titanic.csv&quot;) Il existe plusieurs variantes à la fonction read.csv, la différence réside dans les arguments par défaut. Voir l’aide pour plus d’information : help(&quot;read.csv&quot;) Dans le package utils, chaque fonction dispose de plusieurs arguments, parmi lesquels : file indique le chemin d’accès au fichier header permet de spécifier si la première ligne correspond aux noms des colonnes sep indique par quel caractère sont séparées les colonnes (“\\t” pour les tabulations) dec indique par quel caractère joue le rôle de la décimale (. ou ,) row.names permet de spécifier quel numéro de colonne peut être considéré comme le numéro d’index des lignes na.strings est un vecteur de chaînes de caractères indiquant les valeurs devant être considérées comme manquantes. Ce vecteur vaut c(\"\", \"NA\") par défaut `encoding’ permet de gérer l’encodage Il peut arriver, notamment sous Windows, que l’encodage des caractères accentués ne soit pas correct au moment de l’importation. On peut alors spécifier manuellement l’encodage avec cet argument dataset &lt;- read.csv(file = &quot;C:/Users/anthony.sardellitti/Programmation_Statistique_R/dataset/Titanic.csv&quot;, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, row.names = 1, na.strings = c(NA,&quot;NULL&quot;,&quot;None&quot;), encoding = &quot;Latin-1&quot;) 4.2 Interface interactive d’import de fichiers RStudio propose une interface permettant d’importer un fichier de données de manière interactive. Pour y accéder, dans l’onglet Environment, cliquez sur le bouton Import Dataset. On a ensuite le choix du format de fichier qu’on souhaite importer. Attention, selon le format (Excel ou SAS notamment), l’installation de packages pourront être nécessaire. Dans notre exemple, nous importons un fichier CSV, nous avons donc le choix de l’importer avec les fonctions de base que propose le package utils où alors avec le package readr L’extension `readr fait partie du tidyverse et permet l’importation de fichiers txt, csv, excel mais le nom des fonctions et des arguments sont différents. Sélectionnez From Text (readr)…. Une nouvelle fenêtre s’affiche : Il vous suffit d’indiquer le fichier à importer dans le champ File/URL tout en haut (vous pouvez même indiquer un lien vers un fichier distant via HTTP). Un aperçu s’ouvre dans la partie Data Preview et vous permet de vérifier si l’import est correct : Vous pouvez modifier les options d’importation, changer le type des colonnes, etc. et l’aperçu se met à jour. De même, le code correspondant à l’importation du fichier avec les options sélectionnées est affiché dans la partie Code Preview. Important : une fois que l’import semble correct, ne cliquez pas sur le bouton Import. À la place, sélectionnez le code généré et copiez-le (ou cliquez sur l’icône en forme de presse papier) et choisissez Cancel. Ensuite, collez le code dans votre script et exécutez-le (vous pouvez supprimer la ligne commençant par View). Cette manière de faire permet “d’automatiser” l’importation des données, puisqu’à la prochaine ouverture du script vous aurez juste à exécuter le code en question, sans repasser par l’interface d’import. 4.3 Modifier le répertoire actif La fonction getwd() permet d’afficher le répertoire actif. En général, le chemin proposé est similaire à celui ci : getwd() &quot;C:/Users/anthony.sardellitti/Documents&quot; ## [1] &quot;C:/Users/anthony.sardellitti/Documents&quot; Il est possible de modifier ce chemin. Cela permet notamment d’éviter de saisir le chemin complet d’un fichier de données à l’importation : dataset &lt;- read.csv(file = &quot;C:/Users/anthony.sardellitti/Programmation_Statistique_R/dataset/Titanic.csv&quot;) Pour modifier le répertoire courant, on utilise la fonction setwd()tel que : setwd(&quot;C:/Users/anthony.sardellitti/Programmation_Statistique_R/dataset&quot;) On observe que le chemin a été modifié : getwd() ## [1] &quot;C:/Users/anthony.sardellitti/Programmation_Statistique_R/dataset&quot; On peut également faire la même opération en cliquant sur Session, puis Set Working Directory et Choose Directory. Une fois le répertoire actif modifié, on peut aperçevoir que l’onglet Files renseigne l’ensemble des fichiers présents dans le répertoire actif : On peut donc importer les fichiers présents dans ce répertoire sans préciser leur chemin. dataset &lt;- read.csv(file = &quot;Titanic.csv&quot;) Dans la suite de ce livre, le répertoire actif sera : getwd() ## [1] &quot;D:/GIT/asardell/programmation-r&quot; Cela modifiera quelques peu la définition des chemins des fichiers que nous importerons tels que : dataset &lt;- read.csv(file = &quot;./dataset/Titanic.csv&quot;) 4.4 Import depuis un fichier Excel L’extension readxl, qui fait également partie du tidyverse, permet d’importer des données directement depuis un fichier au format xlsou xlsx. Elle ne fait pas partie du “coeur” du tidyverse, il faut donc la charger explicitement avec : library(readxl) On peut alors utiliser la fonction read_excel en lui spécifiant le nom du fichier : dataset &lt;- read_excel(path = &quot;./dataset/Titanic.xlsx&quot;) Il est possible de spécifier la feuille et la plage de cellules que l’on souhaite importer avec les arguments sheet et range : d &lt;- read_excel(path = &quot;./dataset/Titanic.xlsx&quot;, sheet = &quot;Feuil1&quot;, range = &quot;A1:G1314&quot;) Comme pour l’import de fichiers texte, une interface interactive d’import de fichiers Excel est disponible dans RStudio dans l’onglet Environment. Pour y accéder, cliquez sur Import Dataset puis From Excel…. Spécifiez le chemin ou l’URL du fichier dans le premier champ, vérifiez l’import dans la partie Data Preview, modifiez si besoin les options d’importation, copiez le code d’importation généré dans la partie Code Preview et collez le dans votre script. Pour plus d’informations, voir le site de l’extension readxl. 4.5 Export de données 4.5.1 Export de tableaux de données On peut avoir besoin d’exporter un tableau de données dans R vers un fichier dans différents formats. La plupart des fonctions d’import disposent d’un équivalent permettant l’export de données. On citera notamment : write.csv, permet d’enregistrer un data frame dans un fichier au format texte délimité Il n’existe par contre pas de fonctions permettant d’enregistrer directement au format xls ou xlsx. On peut dans ce cas passer par un fichier CSV. Ces fonctions sont utiles si on souhaite diffuser des données à quelqu’un d’autre, ou entre deux logiciels. Si vous travaillez sur des données de grandes dimensions, les formats texte peuvent être lents à exporter et importer. Dans ce cas, l’extension feather peut être utile : elle permet d’enregistrer un data frame au format feather, qui n’est pas le plus compact mais qui est extrêmement rapide à lire et écrire 7. Les fonctions read_feather et write_feather permettent d’importer et exporter des tableaux de données dans ce format. 4.5.2 Sauvegarder des objets Une autre manière de sauvegarder des données est de les enregistrer au format RData. Ce format propre à R est compact, rapide, et permet d’enregistrer plusieurs objets R, quel que soit leur type, dans un même fichier. Pour enregistrer des objets, il suffit d’utiliser la fonction save et de lui fournir la liste des objets à sauvegarder et le nom du fichier : save(... = d, file = &quot;fichier.RData&quot;) Pour charger des objets préalablement enregistrés, utiliser load : load(file = &quot;fichier.RData&quot;) Les objets ddevrait alors apparaître dans votre environnement. Attention, quand on utilise load, les objets chargés sont importés directement dans l’environnement en cours avec leur nom d’origine. Si d’autres objets du même nom existaient déjà, ils sont écrasés sans avertissement. 4.6 Exercices 4.6.1 Sujet Dans ce qui suit on va utiliser des jeux de données correspondant aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. La base de données est répartie en plusieurs tables. Nous allons utiliser une d’entres elles pour le moment à savoir le fichier flights.csv qui présente 336 776 vols sur 19 variables Voici une description de cette table : year, month, day : date du vol. dep_time, arr_time : Heures de départ et d’arrivée réelles (format HHMM ou HMM). sched_dep_time,sched_arr_time : Heures de départ et d’arrivée prévues (format HHMM ou HMM). dep_delay, arr_delay : Retards de départ et d’arrivée, en minutes. Les temps négatifs représentent des départs / arrivées précoces. carrier : Abréviation à deux lettres des compagnies aériennes. flights : Numéro de vol tailnum : Immatriculation de l’avion origine, dest : Aéroport de départ et destination. air_time : Durée du vol en minutes. distance : Distance entre les aéroports, en miles. hour , minute : Heure de départ prévue divisée en heures et minutes. time_hour : Date et heure prévues du vol year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest air_time distance hour minute time_hour 2013 1 1 517 515 2 830 819 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2013-01-01 05:00:00 2013 1 1 533 529 4 850 830 20 UA 1714 N24211 LGA IAH 227 1416 5 29 2013-01-01 05:00:00 2013 1 1 542 540 2 923 850 33 AA 1141 N619AA JFK MIA 160 1089 5 40 2013-01-01 05:00:00 2013 1 1 544 545 -1 1004 1022 -18 B6 725 N804JB JFK BQN 183 1576 5 45 2013-01-01 05:00:00 2013 1 1 554 600 -6 812 837 -25 DL 461 N668DN LGA ATL 116 762 6 0 2013-01-01 06:00:00 2013 1 1 554 558 -4 740 728 12 UA 1696 N39463 EWR ORD 150 719 5 58 2013-01-01 05:00:00 2013 1 1 555 600 -5 913 854 19 B6 507 N516JB EWR FLL 158 1065 6 0 2013-01-01 06:00:00 2013 1 1 557 600 -3 709 723 -14 EV 5708 N829AS LGA IAD 53 229 6 0 2013-01-01 06:00:00 2013 1 1 557 600 -3 838 846 -8 B6 79 N593JB JFK MCO 140 944 6 0 2013-01-01 06:00:00 2013 1 1 558 600 -2 753 745 8 AA 301 N3ALAA LGA ORD 138 733 6 0 2013-01-01 06:00:00 2013 1 1 558 600 -2 849 851 -2 B6 49 N793JB JFK PBI 149 1028 6 0 2013-01-01 06:00:00 2013 1 1 558 600 -2 853 856 -3 B6 71 N657JB JFK TPA 158 1005 6 0 2013-01-01 06:00:00 2013 1 1 558 600 -2 924 917 7 UA 194 N29129 JFK LAX 345 2475 6 0 2013-01-01 06:00:00 2013 1 1 558 600 -2 923 937 -14 UA 1124 N53441 EWR SFO 361 2565 6 0 2013-01-01 06:00:00 2013 1 1 559 600 -1 941 910 31 AA 707 N3DUAA LGA DFW 257 1389 6 0 2013-01-01 06:00:00 2013 1 1 559 559 0 702 706 -4 B6 1806 N708JB JFK BOS 44 187 5 59 2013-01-01 05:00:00 2013 1 1 559 600 -1 854 902 -8 UA 1187 N76515 EWR LAS 337 2227 6 0 2013-01-01 06:00:00 2013 1 1 600 600 0 851 858 -7 B6 371 N595JB LGA FLL 152 1076 6 0 2013-01-01 06:00:00 2013 1 1 600 600 0 837 825 12 MQ 4650 N542MQ LGA ATL 134 762 6 0 2013-01-01 06:00:00 2013 1 1 601 600 1 844 850 -6 B6 343 N644JB EWR PBI 147 1023 6 0 2013-01-01 06:00:00 Exercice 1 Importez le jeu de données fligths.csv Combien de lignes, colonnes sont présentes dans cette table ? Affichez le nom des colonnes Affichez les 10 premières lignes dans une vue Exercice 2 Affichez un résumé des données Affichez le type des colonnes Transformer la variable flighten caractère Affichez les quartiles de la distribution de la variable arr_delay Affichez les déciles de la distribution de la variable distance Exercice 3 Quel est l’aéroport avec le plus de départ en 2013 ? Avec la fonction unique, affichez le nombre de destinations différentes Proposez une représentation graphique adaptée pour la variable arr_delay Proposez une représentation graphique adaptée pour la variable origin Proposez une représentation graphique adaptée pour la variable dest Même question, mais en affichant uniquement un top 10 4.6.2 Correction Exercice 1 Importez le jeu de données fligths.csv. Attention, en réalité ce jeu de données est issu du package nycflights13 flights &lt;- read.csv(file = &quot;./dataset/flights.csv&quot;, sep = &quot;\\t&quot;) Combien de lignes, colonnes sont présentes dans cette table ? dim(x = flights) ## [1] 336776 19 #ou ncol(x = flights) ; nrow(x = flights) ## [1] 19 ## [1] 336776 Affichez le nom des colonnes colnames(x = flights) #fonctionne aussi avec names(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; Affichez les 10 premières lignes dans une vue View(head(x = flights, n = 10)) Exercice 2 Affichez un résumé des données summary(object = flights) Affichez le type des colonnes str(flights) Transformer la variable flighten caractère flights$flight &lt;- as.character(x = flights$flight) class(x = flights$flight ) ## [1] &quot;character&quot; Affichez les quartiles de la distribution de la variable arr_delay #Attention aux valeurs manquantes quantile(x = flights$arr_delay, na.rm = TRUE) ## 0% 25% 50% 75% 100% ## -86 -17 -5 14 1272 Affichez les déciles de la distribution de la variable distance quantile(x = flights$distance, probs = seq(0,1,0.1)) ## 0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% ## 17 214 427 544 733 872 1023 1096 1598 2446 4983 Exercice 3 Quel est l’aéroport avec le plus de départ en 2013 ? table(x = flights$origin) ## x ## EWR JFK LGA ## 120835 111279 104662 Avec la fonction unique, affichez le nombre de destinations différentes length(x = unique(x = flights$dest)) ## [1] 105 Si la variable dest est de type factor, on peut simplement compter le nombre de levels is.factor(flights$dest) ## [1] TRUE length(levels(flights$dest)) ## [1] 105 Proposez une représentation graphique adaptée pour la variable arr_delay boxplot(x = flights$arr_delay, horizontal = TRUE, main = &quot;Répartition des retards (en minutes)&quot;) Proposez une représentation graphique adaptée pour la variable origin count &lt;- table(flights$origin) pie(x = count, main = &quot;Répartition des vols depuis l&#39;aéroport de départ&quot;, labels = paste(row.names(count),&quot;\\n&quot;,count),col = colors()) Proposez une représentation graphique adaptée pour la variable dest count &lt;- sort(x = table(flights$dest),decreasing = TRUE) barplot(height = count, main = &quot;Nombre de vols pour chaque destination&quot;, las = 2, cex.names = 0.4) Même question, mais en affichant uniquement un top 10 count &lt;- sort(x = table(flights$dest),decreasing = TRUE)[1:10] barplot(height = count, main = &quot;Nombre de vols pour chaque destination \\n TOP 10&quot;, ylim = c(0,20000), col = &quot;blue&quot;) 4.7 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. feather est un format compatible avec Python, R et Julia. Pour plus d’informations, voir https://github.com/wesm/feather↩︎ "],
["manipulation-objet.html", "Chapitre 5 Manipulation des objets 5.1 Liste 5.2 Matrice 5.3 Data frame 5.4 Testez vos connaissances !", " Chapitre 5 Manipulation des objets 5.1 Liste Un vecteur, est une liste d’élément de même type. À l’inverse, une liste est une collection d’objets de différentes classes. La fonction list permet de créer une liste. ma_liste &lt;- list(matrix(data = 1:10, nrow = 2), &quot;Hello world&quot;, c(&quot;Pierre&quot;,&quot;Paul&quot;,&quot;Jacques&quot;)) ma_liste ## [[1]] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## ## [[2]] ## [1] &quot;Hello world&quot; ## ## [[3]] ## [1] &quot;Pierre&quot; &quot;Paul&quot; &quot;Jacques&quot; Pour accéder à un objet d’une liste, on utilise des doubles crochets : par exemple [[ 1 ]] pour le premier objet d’une liste. ma_liste[[1]] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 On peut accéder aux objets d’une liste avec le $lorsque les objets ont des noms. Les noms peuvent être définis lors de la création de la liste ou avec la fonction names. ma_liste &lt;- list(obj1 = matrix(data = 1:10, nrow = 2), obj2 = &quot;Hello world&quot;, obj3 = c(&quot;Pierre&quot;,&quot;Paul&quot;,&quot;Jacques&quot;)) ma_liste$obj1 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 names(ma_liste) &lt;- c(&quot;matrice&quot;, &quot;element&quot;, &quot;vecteur&quot;) ma_liste ## $matrice ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## ## $element ## [1] &quot;Hello world&quot; ## ## $vecteur ## [1] &quot;Pierre&quot; &quot;Paul&quot; &quot;Jacques&quot; Comme pour les vecteurs, la fonction `length’ retourne la longueur d’une liste. length(ma_liste) ## [1] 3 Pour supprimer un objet d’une liste, on lui affecte la valeur NULL ma_liste$matrice &lt;- NULL ma_liste ## $element ## [1] &quot;Hello world&quot; ## ## $vecteur ## [1] &quot;Pierre&quot; &quot;Paul&quot; &quot;Jacques&quot; Pour ajouter un objet à une liste, on affecte un objet à au nom du nouvel objet de la liste qui n’existe pas. ma_liste$matrice2 &lt;- matrix(data = 1:10, nrow = 2) ma_liste ## $element ## [1] &quot;Hello world&quot; ## ## $vecteur ## [1] &quot;Pierre&quot; &quot;Paul&quot; &quot;Jacques&quot; ## ## $matrice2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 5.2 Matrice On sait que qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré. Par exemple : a &lt;- c(1,5,6,9) a[2] ## [1] 5 Cette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur. Dans un objet à deux dimensions comme les matrices, a &lt;- matrix(data = 1:9, nrow = 3, dimnames = list(c(&quot;ligne1&quot;,&quot;ligne2&quot;,&quot;ligne3&quot;), c(&quot;col1&quot;,&quot;col2&quot;,&quot;col3&quot;))) class(a) ## [1] &quot;matrix&quot; a ## col1 col2 col3 ## ligne1 1 4 7 ## ligne2 2 5 8 ## ligne3 3 6 9 on utilise la même syntaxe sauf qu’on précise les index lignes et colonnes entre [] séparés par une virgule. #accéder à l&#39;élément de la 2ème ligne et 3ème colonne a[ 2 , 3] ## [1] 8 #accéder à la deuxième ligne a[ 2 , ] ## col1 col2 col3 ## 2 5 8 #accéder à la troisième colonne a[ , 3 ] ## ligne1 ligne2 ligne3 ## 7 8 9 On peut également effectuer une indexation multiple sur les matrices si on souhaite sélectionner plusieurs lignes et colonnes. a[ , c(1,3)] ## col1 col3 ## ligne1 1 7 ## ligne2 2 8 ## ligne3 3 9 a[c(2,3) , ] ## col1 col2 col3 ## ligne2 2 5 8 ## ligne3 3 6 9 a[c(2,3) , c(1,3) ] ## col1 col3 ## ligne2 2 8 ## ligne3 3 9 Attention : Lorsqu’on effectue une indexation multiple, le résultat renvoyé est dans l’ordre des index précisés dans le vecteur. Nous aborderons de nouveau cette notion lors des tris. a[c(3,2) , c(2,3,1) ] ## col2 col3 col1 ## ligne3 6 9 3 ## ligne2 5 8 2 On peut également effectuer une indexation contraire sur les matrices en précisant toutes les lignes / colonnes que l’on ne veut pas sélectionner. Pour cela, on utilise le ‘-’ devant l’indexation : a[ , -2 ] ## col1 col3 ## ligne1 1 7 ## ligne2 2 8 ## ligne3 3 9 a[- c(2,3) , ] ## col1 col2 col3 ## 1 4 7 Attention : dans une matrice, tous les éléments sont de même type numeric, character ou logique. C’est pourquoi, on travaille avec une autre classe d’objet pour les jeux de données. La classe data.frame. 5.3 Data frame La classe d’objet data.frame partage les mêmes propriétés que la classe matrix pour l’indexation. Un data frame c’est une collection de vecteurs de même taille stockés dans un objet à deux dimensions. Autrement dit, dans un data frame, chaque colonne est un vecteur avec son propre type (numeric, character, factor, logical, date, etc.). Dans cette partie nous allons voir comment manipuler un data.frame sans utiliser le package dplyr. 5.3.1 Indexations simples Un des plus de la classe data.frame c’est la possibilité d’indexer les lignes et les colonnes avec leur nom. a ## col1 col2 col3 ## ligne1 1 4 7 ## ligne2 2 5 8 ## ligne3 3 6 9 class(a) ## [1] &quot;matrix&quot; a$col1 ## Error in a$col1: $ operator is invalid for atomic vectors b &lt;- as.data.frame(x = a) class(b) ## [1] &quot;data.frame&quot; b$col1 ## [1] 1 2 3 b[ c(&quot;ligne1&quot;), c(&quot;col2&quot;,&quot;col1&quot;)] ## col2 col1 ## ligne1 4 1 5.3.2 Indexations avec des booléens Dans le langage R, il est possible d’effectuer des indexations sur des objets avec des booléens TRUE / FALSE. Dans l’exemple ci-dessous, je vais indexer le vecteur avec un vecteur logique de même taille a &lt;- c(4,2,6,9,7) #afficher le 2ème et 4ème éléments a[c(FALSE,TRUE,FALSE,TRUE,FALSE)] ## [1] 2 9 Dans un data frame, on peut utiliser ce procédé pour sélectionner certaines lignes et colonnes : b ## col1 col2 col3 ## ligne1 1 4 7 ## ligne2 2 5 8 ## ligne3 3 6 9 #accéder à la 2ème ligne b [ c(FALSE,TRUE,FALSE), ] ## col1 col2 col3 ## ligne2 2 5 8 #accéder à la 3eme colonne b [ , c(FALSE,FALSE,TRUE) ] ## [1] 7 8 9 #accéder à l&#39;élément de la 2ème ligne et 3ème colonne b [ c(FALSE,TRUE,FALSE), c(FALSE,FALSE,TRUE) ] ## [1] 8 Ainsi, avec des vecteurs logiques, il est possible d’indexer des data.frame. C’est ce mécanisme qui permet d’effectuer des filtres. 5.3.3 Filtre et sélection dans un data frame Pour filtrer un data.frame, il suffit d’insérer un ou plusieurs tests logiques dans l’indexation de l’objet. Pour rappel, les tests logiques retournent toujours des valeurs logiques TRUE / FALSE. a &lt;- c(1,9,7,1,6) a &gt; 5 ## [1] FALSE TRUE TRUE FALSE TRUE b ## col1 col2 col3 ## ligne1 1 4 7 ## ligne2 2 5 8 ## ligne3 3 6 9 b[ b$col1 &gt; 1 , ] ## col1 col2 col3 ## ligne2 2 5 8 ## ligne3 3 6 9 b[ (b$col1 &gt; 1) &amp; (b$col2 &lt; 6) , ] ## col1 col2 col3 ## ligne2 2 5 8 5.3.4 Exercices 5.3.4.1 Sujet Pour illustrer ces notions, on utilise la base de données correspondant aux informations de tous les vols au départ d’un des trois aéroports de New-York en 2013. La base de données est répartie en 5 tables et disponible à partir du package nycflights13. #on charge le package library(nycflights13) #on affiche les objets disponibles du package ls(&quot;package:nycflights13&quot;) ## [1] &quot;airlines&quot; &quot;airports&quot; &quot;flights&quot; &quot;planes&quot; &quot;weather&quot; Nous allons utiliser la table flights qui présente 336 776 vols sur 19 variables Voici une description de cette table : year, month, day : date du vol. dep_time, arr_time : Heures de départ et d’arrivée réelles (format HHMM ou HMM). sched_dep_time,sched_arr_time : Heures de départ et d’arrivée prévues (format HHMM ou HMM). dep_delay, arr_delay : Retards de départ et d’arrivée, en minutes. Les temps négatifs représentent des départs / arrivées précoces. carrier : Abréviation à deux lettres des compagnies aériennes. flights : Numéro de vol tailnum : Immatriculation de l’avion origine, dest : Aéroport de départ et destination. air_time : Durée du vol en minutes. distance : Distance entre les aéroports, en miles. hour , minute : Heure de départ prévue divisée en heures et minutes. time_hour : Date et heure prévues du vol Exercice 1 Installez, puis chargez le package nycflights13 Combien de lignes, colonnes sont présentes dans cette table ? Affichez le nom des colonnes Affichez un résumé des données Exercice 2 Sélectionnez uniquement les colonnes year, month, day. Sélectionnez uniquement les colonnes 13 à 19. Sélectionnez toutes colonnes sauf dep_delay et arr_delay. Exercice 3 Pour répondre aux questions, utilisez des tests logiques sans passer par la fonction subset. Filtrez la table en sélectionnant les vols du mois de janvier. Filtrez la table en sélectionnant les vols en provenance de LGA et JFK. Filtrez la table en sélectionnant les vols avec 10 à 30 min de retards à l’arrivée. Filtrez la table en sélectionnant les vols avec 10 à 30 min de retard à l’arrivée du mois de janvier. 5.3.4.2 Correction Exercice 1 Installez, puis chargez le package nycflights13 library(nycflights13) Combien de lignes, colonnes sont présentes dans cette table ? dim(x = flights) ## [1] 336776 19 Affichez le nom des colonnes colnames(x = flights) Affichez un résumé des données summary(object = flights) Exercice 2 Sélectionnez uniquement les colonnes year, month, day. requeteA &lt;- flights[ , c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;) ] dim(requeteA) ## [1] 336776 3 Sélectionnez uniquement les colonnes 13 à 19. requeteB &lt;- flights[ , 13:19 ] dim(requeteB) ## [1] 336776 7 Sélectionnez toutes colonnes sauf dep_delay et arr_delay. On utilise un test logique sur le nom des colonnes colnames(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; colnames(flights) %in% c(&#39;dep_delay&#39;,&#39;arr_delay&#39;) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE ## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE requeteC &lt;- flights[ , colnames(flights) %in% c(&#39;dep_delay&#39;,&#39;arr_delay&#39;) ] dim(requeteC) ## [1] 336776 2 Exercice 3 Pour répondre aux questions, utilisez des tests logiques sans passer par la fonction subset. Filtrez la table en sélectionnant les vols du mois de janvier. requeteA &lt;- flights[ flights$month == 1 , ] dim(requeteA) ## [1] 27004 19 Filtrez la table en sélectionnant les vols en provenance de LGA et JFK. requeteB &lt;- flights[ flights$origin %in% c(&quot;JFK&quot;,&quot;LGA&quot;) , ] dim(requeteB) ## [1] 215941 19 Filtrez la table en sélectionnant les vols avec 10 à 30 min de retards à l’arrivée. requeteC &lt;- flights[ (flights$arr_delay &gt; 10) &amp; (flights$arr_delay &lt; 30) &amp; (!is.na(flights$arr_delay)), ] dim(requeteC) ## [1] 38819 19 Filtrez la table en sélectionnant les vols avec 10 à 30 min de retard à l’arrivée du mois de janvier. requeteD &lt;- flights[ (flights$arr_delay &gt; 10) &amp; (flights$arr_delay &lt; 30) &amp; (!is.na(flights$arr_delay)) &amp; (flights$month == 1) , ] dim(requeteD) ## [1] 3410 19 5.3.5 Trier un data frame On sait que la fonction sort permet de trier un vecteur. a &lt;- c(1,9,4,6) sort(x = a, decreasing = TRUE) ## [1] 9 6 4 1 La fonction order permet de trier un vecteur à partir des rangs. a &lt;- c(1,9,4,6) order(a,decreasing = TRUE) ## [1] 2 4 3 1 On utilise ensuite le vecteur avec les rangs pour trier le vecteur a[ order(a,decreasing = TRUE) ] ## [1] 9 6 4 1 Pour trier un data frame ou une matrice, on utilise le même procédé avec la fonction order. a &lt;- matrix(data = c(1,4,4,0,7,9,2,5,6), nrow = 3, dimnames = list(c(&quot;ligne1&quot;,&quot;ligne2&quot;,&quot;ligne3&quot;), c(&quot;col1&quot;,&quot;col2&quot;,&quot;col3&quot;))) a ## col1 col2 col3 ## ligne1 1 0 2 ## ligne2 4 7 5 ## ligne3 4 9 6 Ici, on souhaiter trier la matrice selon la deuxième colonne avec un tri décroissant. Seule, la fonction order renvoie les rangs dans lesquels il faudrait trier le tableau. order(a[,2],decreasing = TRUE) ## [1] 3 2 1 Il faut utiliser ce vecteur de rang dans l’indexation de la matrice pour la trier. rang &lt;- order( a[,2],decreasing = TRUE ) a[ rang , ] ## col1 col2 col3 ## ligne3 4 9 6 ## ligne2 4 7 5 ## ligne1 1 0 2 On peut aussi utiliser le ‘-’ devant le vecteur à trier pour effectuer un tri décroissant. rang &lt;- order( - a[,2] ) a[ rang , ] ## col1 col2 col3 ## ligne3 4 9 6 ## ligne2 4 7 5 ## ligne1 1 0 2 C’est cette syntaxe qu’on retrouve pour réaliser des tris successifs, on utilise toujours la fonction order avec chaque vecteur comme argument. On souhaite trier la première colonne par ordre croissant puis la deuxième colonne par ordre décroissant : rang &lt;- order(a[,1] , - a[,2] ) a[ rang , ] ## col1 col2 col3 ## ligne1 1 0 2 ## ligne3 4 9 6 ## ligne2 4 7 5 5.3.6 Exercice 5.3.6.1 Sujet Nous utilisons toujours la table flights. Pour faciliter la lecture des résultats des requêtes, n’affichez que : les 5 premières lignes la colonne flight, tailnum et celles avec le(s) tri(s) concerné(s) Exercice 1 Trier la table selon le mois du vol Trier la table selon les vols avec le plus de retard à l’arrivée Trier la table par vols de provenance, puis de destination 5.3.6.2 Correction Exercice 1 Trier la table selon le mois du vol rang &lt;- order(flights$month) requeteA &lt;- flights[ rang , c(&quot;flight&quot;, &quot;tailnum&quot;, &quot;month&quot;) ] flight tailnum month 1545 N14228 1 1714 N24211 1 1141 N619AA 1 725 N804JB 1 461 N668DN 1 Trier la table selon les vols avec le plus de retard à l’arrivée rang &lt;- order(-flights$arr_delay) requeteB &lt;- flights[ rang , c(&quot;flight&quot;, &quot;tailnum&quot;, &quot;arr_delay&quot;) ] flight tailnum arr_delay 7073 51 N384HA 1272 235779 3535 N504MQ 1127 8240 3695 N517MQ 1109 327044 177 N338AA 1007 270377 3075 N665MQ 989 Trier la table par vols de provenance, puis de destination rang &lt;- order(flights$origin, flights$dest) requeteC &lt;- flights[ rang , c(&quot;flight&quot;, &quot;tailnum&quot;, &quot;origin&quot;, &quot;dest&quot;) ] flight tailnum origin dest 361 4112 N13538 EWR ALB 570 3260 N19554 EWR ALB 785 4170 N12540 EWR ALB 1280 4316 N14153 EWR ALB 1537 3260 N14153 EWR ALB 5.3.7 Agréger des données Le langage R permet aussi d’effectuer des opérations groupées en effectuant des agrégations. Pour cela on utilise la fonction aggregate. Il faut préciser dans la fonction le champ avec lequel on souhaite grouper les données, puis la fonction d’agrégation à utiliser. Ici, on calcule le retard moyen au départ pour chaque aéroport d’origine : agregation &lt;- aggregate(formula = dep_delay ~ origin, data = flights , FUN = mean) origin dep_delay EWR 15.10795 JFK 12.11216 LGA 10.34688 On peut également grouper les données selon plusieurs champs qu’on renseigne avec le ‘+’ dans l’argument formula. Ici on calcule le retard moyen au départ pour chaque aéroport d’origine et chaque mois : agregation &lt;- aggregate(formula = dep_delay ~ origin + month, data = flights , FUN = mean) origin month dep_delay EWR 1 14.905748 JFK 1 8.615826 LGA 1 5.641560 EWR 2 13.067263 JFK 2 11.791355 LGA 2 6.961582 Le raccourci ‘.’ dans l’argument formula permet d’agréger toutes les colonnes en fonction ‘~’ d’une ou plusieurs. agregation &lt;- aggregate(formula = . ~ origin, data = flights[ , c(&quot;origin&quot;,&quot;dep_delay&quot;,&quot;arr_delay&quot;,&quot;distance&quot;)], FUN = mean) origin dep_delay arr_delay distance EWR 15.00911 9.107055 1064.7522 JFK 12.02361 5.551481 1275.2106 LGA 10.28658 5.783488 784.7561 5.3.8 Exercice 5.3.8.1 Sujet Exercice 1 Calculez le retard maximum au départ de chaque aéroport Calculez l’écart-type sur les retards au départ et l’arrivée pour chaque aéroport d’origine Calculez le nombre de vols par aéroport d’origine 5.3.8.2 Correction Calculez le retard maximum au départ de chaque aéroport agregationA &lt;- aggregate(formula = dep_delay ~ origin, data = flights, FUN = max) origin dep_delay EWR 1126 JFK 1301 LGA 911 Calculez l’écart-type sur les retards au départ et l’arrivée pour chaque aéroport d’origine agregationB &lt;- aggregate(formula = . ~ origin, data = flights[ , c(&quot;origin&quot;,&quot;dep_delay&quot;, &quot;arr_delay&quot;)], FUN = sd) origin dep_delay arr_delay EWR 41.18521 45.52918 JFK 38.82710 44.27745 LGA 39.91130 43.86227 Calculez le nombre de vols par aéroport d’origine agregationC &lt;- aggregate(formula = tailnum ~ origin, data = flights, FUN = length) origin tailnum EWR 120229 JFK 110370 LGA 103665 5.4 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. "],
["graphique.html", "Chapitre 6 Représentation Graphique 6.1 Les fenêtres graphiques 6.2 Les fonctions de tracé de bas niveau 6.3 Personnaliser des éléments graphiques 6.4 Type de graphique 6.5 Exercice 6.6 Aller plus loin 6.7 Testez vos connaissances !", " Chapitre 6 Représentation Graphique Cette partie est destinée à présenter comment construire et personnaliser des graphiques sous R. Jusqu’à présent, on a abordé brièvement les graphiques univariés dans les parties précédentes à travers les fonctions barplot, boxplot, et hist.Volontairement, nous ferons les premiers pas sans utiliser le package ggplot2 que nous verrons plus tard. Pour un tutoriel complet de ggplot2 vous pouvez vous dirigez vers le cours de Julien Barnier Pour illustrer les concepts, nous travaillerons sur les données iris. Un jeu de données de 150 fleurs réparties en 3 espèces différentes (setosa, versicolor et virginica) et caractérisées par 4 variables quantitatives. Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 6.1 Les fenêtres graphiques La fenêtre graphique de RStudio permet d’afficher les graphiques qui ont été générés. Le bouton Export permet d’exporter le graphique en tant qu’image ou pdf. On peut aussi exporter un graphique avec la fonction dev.print. dev.print(device = png, file = &quot;export.png&quot;, width = 600) Il est possible de découper la fenêtre graphique pour en afficher plusieurs à la fois. Pour cela on utilise la fonction par avec l’argument mfrow en précisant le découpage de la fenêtre. par(mfrow=c(1,2)) #fenêtre sur une ligne et deux colonnes plot(iris$Sepal.Length,iris$Sepal.Width) plot(iris$Petal.Length,iris$Petal.Width) Pour réinitialiser le découpage de la fenêtre graphique, on redimensionne la fenêtre sur 1 x 1. par(mfrow=c(1,1)) 6.2 Les fonctions de tracé de bas niveau Nous allons illustrer les fonctions graphiques du langage R à travers la représentation d’un nuage de points. Pour construire un nuage de points, on utilise la fonction plot en précisant les deux vecteurs numériques que l’on souhaite projeter. plot(x = iris$Sepal.Length,y = iris$Sepal.Width, xlab = &quot;Sepal Length&quot;,ylab = &quot;Sepal Width&quot;) Dans l’exemple ci-dessus, on précise les caractéristiques du graphique directement dans la fonction plot. Mais, il est également possible d’ajouter des éléments avec d’autres fonctions issues notamment du package graphics déjà chargé par défaut dans RStudio. #Ajouter des éléments plot(x = iris$Sepal.Length,y = iris$Sepal.Width, xlim = c(4,9),ylim = c(1,5), xlab = &quot;Sepal Length&quot;,ylab = &quot;Sepal Width&quot;) #Ajouter un titre title(main = &quot;Sepal Width and Sepal Length&quot;) #Ajouter un sous titre mtext(text = &quot;(Source : Iris)&quot;,side=4) #Ajouter des lignes abline(h = 3) abline(v = 6) #Ajouter du texte text(x = 5,y = 1.5,labels = &quot;Groupe 1&quot;) text(x = 5,y = 4.5,labels = &quot;Groupe 2&quot;) text(x = 7,y = 4.5,labels = &quot;Groupe 3&quot;) text(x = 7,y = 2,labels = &quot;Groupe 4&quot;) #Ajouter des points points(x = c(9,9,9),y = c(4,4.5,5)) Attention : Les fonctions des éléments graphiques ajoutent les éléments sur le graphique en cours de lecture dans la fenêtre graphique. 6.3 Personnaliser des éléments graphiques 6.3.1 Mise en forme On peut aussi personnaliser les différents éléments du graphique en utilisant les arguments de chaque fonction. plot(x = iris$Sepal.Length,y = iris$Sepal.Width, xlim = c(4,9),ylim = c(1,5), xlab = &quot;Sepal Length&quot;,ylab = &quot;Sepal Width&quot;, col = iris$Species, pch = 19 ) title(main = &quot;Sepal Width and Sepal Length&quot;, cex.main = 2,font.main=4, col.main= &quot;red&quot;) mtext(text = &quot;(Source : Iris)&quot;,side=4, font=2) abline(h = 3 , lty = 3 , lwd = 4) abline(v = 6 , lty = 3 , lwd = 2) text(x = 5,y = 1.5,labels = &quot;Groupe 1&quot;, col = 3) text(x = 5,y = 4.5,labels = &quot;Groupe 2&quot;, col = 2) text(x = 7,y = 4.5,labels = &quot;Groupe 3&quot;, col = 4) text(x = 7,y = 2,labels = &quot;Groupe 4&quot;, col = 5) points(x = c(9,9,9),y = c(4,4.5,5), pch = 4 , col = c(&quot;red&quot;,&quot;blue&quot;)) legend(x = &quot;bottomright&quot;, legend=levels(iris$Species), col=c(1:3), pch = 19, cex=0.8) legend(x = 6.5, y=1.5, legend=&quot;points \\n supplémentaires&quot;, pch = 4, cex=0.8 , box.lty=0) Par exemple l’argument pch définit la forme du point et l’argument lty la forme du trait. Voici une table de correspondance : 6.3.2 Gestion des couleurs Dans R, la gestion des couleurs est assez simple. Jusqu’à présent, pour construire les graphiques on se contentait de renseigner les arguments col des fonctions avec le nom d’une couleur comme red, blue, ou de préciser des numéros dans des vecteurs comme c(1,2,3). Mais comment R fait-il pour interpréter cela ? plot(x = iris$Sepal.Length,y = iris$Sepal.Width, col = c(&quot;red&quot;)) plot(x = iris$Sepal.Length,y = iris$Sepal.Width, col = 3) En réalité, il existe une palette par défaut dans R. Elle est composée de 8 couleurs. On peut les retrouver avec la fonction palette(). palette() ## [1] &quot;black&quot; &quot;red&quot; &quot;green3&quot; &quot;blue&quot; &quot;cyan&quot; &quot;magenta&quot; &quot;yellow&quot; ## [8] &quot;gray&quot; Ainsi, on peut définir les couleurs que l’on souhaite dans cette palette en précisant le nom ou le numéro de la couleur. C’est pourquoi, il est possible de définir les couleurs de différentes catégories si le vecteur est défini en tant que factor. class(iris$Species) ## [1] &quot;factor&quot; plot(x = iris$Sepal.Length,y = iris$Sepal.Width, col = iris$Species, pch = 19) legend(x = &quot;bottomright&quot;, legend=levels(iris$Species), col=c(1:3), pch = 19, cex=0.8) Dans R, un vecteur de type factor est stocker au format numérique en mémoire ou chaque nombre représente l’indice du niveau associé à la catégorie. levels(iris$Species) ## [1] &quot;setosa&quot; &quot;versicolor&quot; &quot;virginica&quot; L’espèce setosa prendra la valeur 1, versicolor la valeur 2 et virignica la valeur 3. Ces niveaux seront donc associés aux 3 premières couleurs de la palette par défaut. palette()[1:3] ## [1] &quot;black&quot; &quot;red&quot; &quot;green3&quot; On aura donc black pour setosa, red pour versicolor et green3 pour virginica. Attention donc lorsqu’on souhaite représenter des points selon une variable qualitative. Dans l’exemple ci-dessous, on définit 3 couleurs sans tenir compte de l’espèce et nous n’obtenons pas du tout le même résultat. plot(x = iris$Sepal.Length,y = iris$Sepal.Width, col = c(1,2,3), pch = 19) En précisant uniquement 3 couleurs, l’argument col va en réalité prendre en entrée un vecteur de longueur 150 ou le trio de couleur sera répliqué 50 fois pour qu’à chaque fleur soit associée une couleur. trio_replique &lt;- rep(c(1,2,3), 50) trio_replique ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 ## [36] 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 ## [71] 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 ## [106] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 ## [141] 3 1 2 3 1 2 3 1 2 3 On obtient le même graphique que ci-dessous et en l’occurrence les deux sont faux car les couleurs ne sont pas définies en fonction des espèces. plot(x = iris$Sepal.Length,y = iris$Sepal.Width, col = trio_replique, pch = 19) De plus, on constate que nous sommes limitées en nombre de couleurs. Dès lors que nous souhaitons représenter plus de 8 couleurs, nous faisons face au phénomène de réplication de R. plot(x = rep(1,20),pch=20, col=1:20, cex=4) abline(v = 8.5) abline(v = 16.5) On peut alors utiliser la fonction colors() qui propose une palette de plus de 650 couleurs avec le même mécanisme que la palette par défaut. head(colors(), n = 20) ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; &quot;antiquewhite1&quot; ## [5] &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; &quot;antiquewhite4&quot; &quot;aquamarine&quot; ## [9] &quot;aquamarine1&quot; &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; ## [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; &quot;azure3&quot; ## [17] &quot;azure4&quot; &quot;beige&quot; &quot;bisque&quot; &quot;bisque1&quot; length(colors()) ## [1] 657 plot(x = rep(1,20),pch=20, col= c(&quot;antiquewhite2&quot;,&quot;aquamarine2&quot;, &quot;azure2&quot;), cex = 4) plot(x = rep(1,20),pch=20, col= c(&quot;antiquewhite2&quot;,&quot;aquamarine2&quot;, &quot;azure2&quot;) , cex = 4) Pour personnaliser les couleurs dans R, on utilise donc des vecteurs en appelant les couleurs par leur nom ou leur indice. Cependant, en mémoire les couleurs sont codées en héxadécimales. C’est avec ce format que nous allons pouvoir créer notre propre palette de couleurs. Pour cela, il suffit de construire un vecteur avec les valeurs en héxadécimales des couleurs qu’on souhaite. On peut également utiliser la fonction rgb et l’argument alpha pour gérer la transparence. Le site https://htmlcolorcodes.com/fr/ propose toutes les couleurs qu’il est possible de définir. ma_palette &lt;- c( vert = &quot;#2FB846&quot;, bleu = rgb(red = 4/255,green = 12/255 ,blue = 250/255 , alpha = 0.5)) ma_palette ## vert bleu ## &quot;#2FB846&quot; &quot;#040CFA80&quot; par(mfrow = c(1,2)) plot(x = rep(1,20),pch=20, col= ma_palette , cex = 4) plot(x = rep(1,20),pch=20, col= ma_palette[c(&quot;vert&quot;)] , cex = 4) 6.4 Type de graphique Dans cette partie, nous allons énumérer les graphiques les plus populaires illustrés avec le dataset des applications google. Les différents éléments de personnalisation abordés précédemment sont disponibles pour n’importe quel type de graphique. Le dataset google.csv décrit des applications du store google. Le fichier est issu du site Kaggle. Il a été adapté dans ce livre. Voici la présentation du jeu de données : App : Nom de l’application Category : Catégorie de l’application Rating : Note moyenne des utilisateurs Reviews : Nombre d’avis d’utilisateurs Installs : Nombre d’installation Type : Application gratuite / payante Price : Prix de l’application Content.Rating : Public concerné Last.Updated : Date de la dernière version Size_recode : Taille de l’application (en Mo) App Category Rating Reviews Installs Type Price Content.Rating Last.Updated Size_recode Photo Editor &amp; Candy Camera &amp; Grid &amp; ScrapBook ART_AND_DESIGN 4.1 159 1e+04 Free 0 Everyone 2018-01-07T00:00:00Z 19.0 Coloring book moana ART_AND_DESIGN 3.9 967 5e+05 Free 0 Everyone 2018-01-15T00:00:00Z 14.0 U Launcher Lite – FREE Live Cool Themes, Hide Apps ART_AND_DESIGN 4.7 87510 5e+06 Free 0 Everyone 2018-08-01T00:00:00Z 8.7 Sketch - Draw &amp; Paint ART_AND_DESIGN 4.5 215644 5e+07 Free 0 Teen 2018-06-08T00:00:00Z 25.0 Pixel Draw - Number Art Coloring Book ART_AND_DESIGN 4.3 967 1e+05 Free 0 Everyone 2018-06-20T00:00:00Z 2.8 Paper flowers instructions ART_AND_DESIGN 4.4 167 5e+04 Free 0 Everyone 2017-03-26T00:00:00Z 5.6 Smoke Effect Photo Maker - Smoke Editor ART_AND_DESIGN 3.8 178 5e+04 Free 0 Everyone 2018-04-26T00:00:00Z 19.0 Infinite Painter ART_AND_DESIGN 4.1 36815 1e+06 Free 0 Everyone 2018-06-14T00:00:00Z 29.0 Garden Coloring Book ART_AND_DESIGN 4.4 13791 1e+06 Free 0 Everyone 2017-09-20T00:00:00Z 33.0 Kids Paint Free - Drawing Fun ART_AND_DESIGN 4.7 121 1e+04 Free 0 Everyone 2018-07-03T00:00:00Z 3.1 Text on Photo - Fonteee ART_AND_DESIGN 4.4 13880 1e+06 Free 0 Everyone 2017-10-27T00:00:00Z 28.0 Name Art Photo Editor - Focus n Filters ART_AND_DESIGN 4.4 8788 1e+06 Free 0 Everyone 2018-07-31T00:00:00Z 12.0 Tattoo Name On My Photo Editor ART_AND_DESIGN 4.2 44829 1e+07 Free 0 Teen 2018-04-02T00:00:00Z 20.0 Mandala Coloring Book ART_AND_DESIGN 4.6 4326 1e+05 Free 0 Everyone 2018-06-26T00:00:00Z 21.0 3D Color Pixel by Number - Sandbox Art Coloring ART_AND_DESIGN 4.4 1518 1e+05 Free 0 Everyone 2018-08-03T00:00:00Z 37.0 Learn To Draw Kawaii Characters ART_AND_DESIGN 3.2 55 5e+03 Free 0 Everyone 2018-06-06T00:00:00Z 2.7 Photo Designer - Write your name with shapes ART_AND_DESIGN 4.7 3632 5e+05 Free 0 Everyone 2018-07-31T00:00:00Z 5.5 350 Diy Room Decor Ideas ART_AND_DESIGN 4.5 27 1e+04 Free 0 Everyone 2017-11-07T00:00:00Z 17.0 FlipaClip - Cartoon animation ART_AND_DESIGN 4.3 194216 5e+06 Free 0 Everyone 2018-08-03T00:00:00Z 39.0 ibis Paint X ART_AND_DESIGN 4.6 224399 1e+07 Free 0 Everyone 2018-07-30T00:00:00Z 31.0 6.4.1 Boxplot Les points représentent les outliers. L’argument horizontal permet de représenter le graphique à l’horizontal. D’autres arguments sont disponibles (cf : aide). boxplot(x = google$Rating, main = &quot;Distribution des notes des utilisateurs&quot;, horizontal = TRUE,col = ma_palette) Il est possible de construire un boxplot dans un cadre bivarié : boxplot(formula = google$Rating ~ google$Content.Rating, main = &quot;Distribution des notes des utilisateurs&quot;, col = c(ma_palette, &quot;red&quot;)) Ici on utilise les couleurs de palette différentes. 6.4.2 Histogramme L’argument breaks permet de définir le nombre de classe et probability d’afficher la densité plutôt que les effectifs ou fréquence. D’autres arguments sont disponibles (cf : aide). hist(x = google$Rating, main = &quot;Distribution des notes des utilisateurs&quot;, col = ma_palette[2] , breaks = 8, probability = TRUE) La fonction lines permet d’ajouter une courbe sur un graphique existant. Ici on représente la courbe densité avec la fonction density. hist(x = google$Rating, main = &quot;Distribution des notes des utilisateurs&quot;, col = ma_palette[2] , breaks = 8, probability = TRUE) lines(density(google$Rating), lty = 2, col = ma_palette[1], lwd = 4) 6.4.3 Diagramme en circulaire L’argument labels permet de renseigner les étiquettes du graphique. Si on souhaite afficher les étiquettes en pourcentage, il faut calculer un tri à plat avec les pourcentages. D’autres arguments sont disponibles (cf : aide). tri_a_plat &lt;- table(google$Type) tri_a_plat ## ## Free Paid ## 7592 604 paste(rownames(tri_a_plat),tri_a_plat) ## [1] &quot;Free 7592&quot; &quot;Paid 604&quot; pie(x = tri_a_plat, main = &quot;Repartition du nombre d&#39;applications par type&quot;, col = ma_palette, labels = paste(rownames(tri_a_plat),tri_a_plat)) 6.4.4 Diagramme en barre Même principe pour le diagramme en barre, on doit calculer un tri à plat dans un premier temps. L’argument horiz permet de représenter le graphique à l’horizontal. D’autres arguments sont disponibles (cf : aide). tri_a_plat &lt;- table(google$Type) barplot(height = tri_a_plat, main = &quot;Repartition du nombre d&#39;applications par type&quot;, col = colors()[c(45,99)], horiz = TRUE) Il est possible de construire un diagramme en barre dans un cadre bivarié. L’argument beside permet de préciser si on souhaite un diagramme empilé ou non. La fonction prop.table permet d’obtenir un tableau en pourcentage. tri_croise &lt;- prop.table(table(google$Content.Rating, google$Type)) tri_croise ## ## Free Paid ## Adults only 18+ 0.0003660322 0.0000000000 ## Everyone 0.7448755490 0.0625915081 ## Everyone 10+ 0.0334309419 0.0037823328 ## Mature 17+ 0.0417276720 0.0018301611 ## Teen 0.1057833089 0.0054904832 ## Unrated 0.0001220107 0.0000000000 par(mfrow = c(1,2)) barplot(height = tri_croise, legend = rownames(tri_croise)) barplot(height = tri_croise, legend = rownames(tri_croise) , beside = TRUE) 6.4.5 Nuage de points Ici on représente un nuage de points avec la présentation par défaut. plot(x = google$Reviews, y = google$Rating) Puis le même en y ajoutant des éléments de personnalisation. class(google$Content.Rating) ## [1] &quot;factor&quot; plot(x = google$Reviews, y = google$Rating, pch = 19, cex = 0.5, xlim = c(0,3e+7), col = google$Content.Rating) legend(x = &quot;bottomright&quot;, legend=levels(google$Content.Rating), col = 1:length(levels(google$Content.Rating)), pch = 19, cex=0.8) 6.5 Exercice 6.5.1 Sujet Dans ce TD, on utilise le fichier pokemon.xlsx qui décrit les statistiques des pokemon des deux premières générations. Le fichier est issu du site Kaggle. Il a été adapté pour ce TP. Voici une description des données : pokedex_number : numéro du pokemon nom : nom du pokemon generation : le numéro de génération dont est issu le pokemon is_legendary : Oui / Non si le pokemon est légendaire type : le type du pokemon weight_kg : le poids du pokemon en kg height_m : la taille du pokemon en mètre attack : la puissance d’attaque du pokemon defense : la puissance de défense du pokemon speed : la vitesse du pokemon pokedex_number nom generation is_legendary type weight_kg height_m attack defense speed 1 Bulbizarre 1 Non grass 6.9 0.7 49 49 45 2 Herbizarre 1 Non grass 13.0 1.0 62 63 60 3 Florizarre 1 Non grass 100.0 2.0 100 123 80 4 Salameche 1 Non fire 8.5 0.6 52 43 65 5 Reptincel 1 Non fire 19.0 1.1 64 58 80 6 Dracaufeu 1 Non fire 90.5 1.7 104 78 100 7 Carapuce 1 Non water 9.0 0.5 48 65 43 8 Carabaffe 1 Non water 22.5 1.0 63 80 58 9 Tortank 1 Non water 85.5 1.6 103 120 78 10 Chenipan 1 Non bug 2.9 0.3 30 35 45 11 Chrysacier 1 Non bug 9.9 0.7 20 55 30 12 Papilusion 1 Non bug 32.0 1.1 45 50 70 13 Aspicot 1 Non bug 3.2 0.3 35 30 50 14 Coconfort 1 Non bug 10.0 0.6 25 50 35 15 Dardargnan 1 Non bug 29.5 1.0 150 40 145 16 Roucool 1 Non normal 1.8 0.3 45 40 56 17 Roucoups 1 Non normal 30.0 1.1 60 55 71 18 Roucarnage 1 Non normal 39.5 1.5 80 80 121 19 Rattata 1 Non normal NA NA 56 35 72 20 Rattatac 1 Non normal NA NA 71 70 77 Importez le jeu de données pokemon.xlsx à l’aide du package readxl. Combien de lignes, colonnes sont présentes dans cette table ? Affichez le nom des colonnes Affichez un résumé des données Construire un diagramme en barre du nombre de pokemon par type avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Construire un diagramme circulaire présentant la répartition du nombre de pokemon légendaires ou non (is_legendary) avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Construire un diagramme empilé présentant la répartition en pourcentage du nombre de pokemon légendaires ou non pour chaque génération avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Construire un histogramme de la distribution de la vitesse (speed) des pokemon avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Construire un nuage de points de la vitesse (speed) et du poids (weight_kg) des pokemon avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Puis, calculez le coefficient de corrélation entre ces deux variables avec la fonction cor. ## [1] &quot;Le coefficient de corrélation est :&quot; ## [1] 0.1525117 Construire un diagramme en boîte de la distribution de la statistique speed des pokemon avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Construire un diagramme en boîte de la distribution de la statistique attack des pokemon selon le type avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. 6.5.2 Correction Importez le jeu de données pokemon.xlsx à l’aide du package readxl. library(readxl) pokemon &lt;- read_excel(path = &quot;./dataset/pokemon.xlsx&quot;, sheet = &quot;pokemon&quot;) Combien de lignes, colonnes sont présentes dans cette table ? dim(pokemon) Affichez le nom des colonnes colnames(pokemon) Affichez un résumé des données summary(pokemon) Construire un diagramme en barre du nombre de pokemon par type avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. count &lt;- table(pokemon$type) par(mfrow = c(1,2)) barplot(count, cex.names = 0.4) barplot(sort(count, decreasing = TRUE), horiz = TRUE, las = 2, xlab = &quot;Nombre de pokemon&quot;, col = &quot;yellow&quot;, col.main = &quot;blue&quot;, main = &quot;Nombre de pokemon \\n par type&quot;) Construire un diagramme circulaire présentant la répartition du nombre de pokemon légendaires ou non (is_legendary) avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. count &lt;- table(pokemon$is_legendary) par(mfrow = c(1,2)) pie(count) pie(count, main = &quot;Repartition pokemon \\n legendaire ou non&quot;, col = c(&quot;yellow&quot;,&quot;blue&quot;), col.main = &quot;blue&quot;, labels = paste(rownames(count),count)) Construire un diagramme empilé présentant la répartition en pourcentage du nombre de pokemon légendaires ou non pour chaque génération avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. count &lt;- table(pokemon$is_legendary, pokemon$generation) count_freq &lt;- prop.table(count,margin = 2) par(mfrow = c(1,2)) barplot(count_freq, legend = rownames(count_freq)) barplot(count_freq, las = 2, xlab = &quot;Nombre de pokemon&quot;, main = &quot;Nb pokemon par generation si legendaire&quot;, col = c(&quot;yellow&quot;,&quot;blue&quot;), legend = rownames(count_freq), beside = TRUE) Construire un histogramme de la distribution de la vitesse (speed) des pokemon avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. par(mfrow = c(1,2)) hist(x = pokemon$speed) hist(x = pokemon$speed, breaks = 20, probability = TRUE, col = &quot;yellow&quot;, xlab = &quot;Vitesse&quot;, main = &quot;Histo. de la vitesse des pokemon&quot;, col.main = &quot;blue&quot;) Construire un nuage de points de la vitesse (speed) et du poids (weight_kg) des pokemon avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. Puis, calculez le coefficient de corrélation entre ces deux variables avec la fonction cor. par(mfrow = c(1,2)) plot(x = pokemon$speed, y = pokemon$weight_kg) plot(x = pokemon$speed, y = pokemon$weight_kg, col = as.factor(pokemon$is_legendary)) legend(x = &quot;topright&quot;, legend = c(&quot;Legendaire : Oui&quot;, &quot;Legendaire : Non&quot;), col= 1:2, cex=1, pch = 1) #On récupère les statistiques de Mewtwo Mewtwo &lt;- pokemon[pokemon$nom == &quot;Mewtwo&quot;, c(&quot;speed&quot;, &quot;weight_kg&quot;)] #On les affiche avec la fonction text text(x = Mewtwo[1], y = Mewtwo[2]+40, labels = &quot;Mewtwo&quot;) #argument use pour gérer les NA (voir aide) cor(x = pokemon$speed, y = pokemon$weight_kg, use = &quot;complete.obs&quot;) ## [1] 0.1525117 Construire un diagramme en boîte de la distribution de la statistique speed des pokemon avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. par(mfrow = c(1,2)) boxplot(x = pokemon$speed, main = &quot;Boxplot Speed&quot;) boxplot(x = pokemon$speed, main = &quot;Boxplot Speed&quot;, range = 0, xlab = &quot;Speed&quot;, col = &quot;yellow&quot;) points(mean(pokemon$speed,na.rm = TRUE), cex = 2, pch = 19, col = &quot;blue&quot;) legend(x = &quot;bottomright&quot;, legend= &quot;Moyenne&quot;, col= &quot;blue&quot;, pch = 19, cex=1) Construire un diagramme en boîte de la distribution de la statistique attack des pokemon selon le type avec les paramètres par défaut puis essayez de le personnaliser comme ci-dessous. par(mfrow = c(1,2)) boxplot(formula = attack ~ type, data = pokemon, main = &quot;Boxplot Attack vs Type&quot;) boxplot(formula = attack ~ type, data = pokemon, main = &quot;Boxplot Attack vs Type&quot;, las = 2, col = colors()) 6.6 Aller plus loin Utiliser le package ggplot2 avec le cours de Julien Barnier Constuire des graphiques avec l’interface esquisse avec le cours de Dreams Rs Utiliser des widgets HTML avec la Galerie pour construire des graphiques dynamiques 6.7 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. "],
["algo.html", "Chapitre 7 Algorithme 7.1 Construire une fonction 7.2 Construire une structure conditionnelle 7.3 Construire une boucle 7.4 Exercice 7.5 Testez vos connaissances !", " Chapitre 7 Algorithme 7.1 Construire une fonction Il est possible de programmer ses propres fonctions. Dans l’exemple ci-dessous on construit une fonction imcq ui prend en entrée deux arguments poids et taille. La fonction effectue un calcul et renvoi l’IMC. Pour construire une fonction, on doit obligatoirement faire appel au mot clé function. Le mot clé return n’est pas obligatoire. Cependant, par convention, une fonction renvoie toujours un résultat qui peut aussi être un message d’information sur le bon déroulement de celle-ci. Les arguments sont précisés entre parenthèses ( ). Les traitements s’effectuent entre accolades { }. imc &lt;- function(taille,poids) { calcul &lt;- poids / (taille^2) return (calcul) } Lorsqu’on vérifie la classe de l’objet imc en mémoire, on constate qu’il est bien de type function. class(imc) ## [1] &quot;function&quot; Puis c’est le même principe que les autres fonctions pour l’utiliser : imc(taille = 1.55, poids = 49) ## [1] 20.39542 Il est possible de préciser des arguments par défaut. Ils sont à saisir dans la définition des arguments : imc &lt;- function(taille = 1.70, poids = 60) { calcul &lt;- poids / (taille^2) return (calcul) } imc() ## [1] 20.76125 7.2 Construire une structure conditionnelle Pour construire des structures conditionnelles en R, on utilise le mot clé if avec la ou les conditions à tester entre parenthèses ( ). Si la condition retourne TRUE, l’ensemble des commandes présentent dans les accolades { } seront exécutées. x &lt;- c(1,3,5) if ( sum(x) &gt; 4 ) { print(&quot;Total supérieur à 4&quot;) print(&quot;Fin du traitement&quot;) } ## [1] &quot;Total supérieur à 4&quot; ## [1] &quot;Fin du traitement&quot; On peut aussi utiliser le mot clé else pour exécuter un traitement lorsque la condition retourne FALSE. Attention, petite particularité de R, il faut que le mot clé else soit sur la même ligne de l’accolade qui le bloc if. Dernière particularité, jusqu’à présent on pouvait se passer de la fonction print pour afficher des résultats dans la console. Désormais, cette fonction est obligatoire dans les structures conditionnelles. x &lt;- c(1,3,5) if ( sum(x) &gt; 4 ) { print(&quot;Total supérieur à 4&quot;) print(&quot;Fin du traitement&quot;) } else { print(&quot;Total inférieur ou égale à 4&quot;) print(&quot;Fin du traitement&quot;) } ## [1] &quot;Total supérieur à 4&quot; ## [1] &quot;Fin du traitement&quot; On peut donc réaliser n’importe quelS tests logiques dans une structure conditionnelle. On peut par exemple tester la classe d’un objet avec les fonctions is.classe_a_tester comme is.numeric qui renvoie TRUE ou FALSE. Pour rappel, voici la liste des opérateurs de comparaisons : Pour rappel, voici la liste des opérateurs logiques : 7.3 Construire une boucle Pour répéter un traitement et éviter les copier-coller, on a souvent recours aux boucles. Celles qu’on retrouve principalement dans le langage R est la boucle for et while. La syntaxe utilisée est très proche de celles des structures conditionnelles. Attention, jusqu’à présent on pouvait se passer de la fonction print pour afficher des résultats dans la console. Désormais, cette fonction est obligatoire dans les boucles comme pour les structures conditionnelles. 7.3.1 La boucle for La boucle for parcourt les éléments d’un vecteur qu’on lui indique en entrée. for ( i in c(&quot;Pierre&quot;,&quot;Paul&quot;,&quot;Jacques&quot;)) { print(paste(&quot;Salut &quot;, i)) print(&quot;Traitement terminé !&quot;) } ## [1] &quot;Salut Pierre&quot; ## [1] &quot;Traitement terminé !&quot; ## [1] &quot;Salut Paul&quot; ## [1] &quot;Traitement terminé !&quot; ## [1] &quot;Salut Jacques&quot; ## [1] &quot;Traitement terminé !&quot; La boucle for parcourt les vecteurs d’un data frame / matrice qu’on lui indique en entrée. for ( i in iris) { print(summary(i)) print(&quot;Traitement terminé !&quot;) } ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 ## [1] &quot;Traitement terminé !&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.000 2.800 3.000 3.057 3.300 4.400 ## [1] &quot;Traitement terminé !&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 1.600 4.350 3.758 5.100 6.900 ## [1] &quot;Traitement terminé !&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.100 0.300 1.300 1.199 1.800 2.500 ## [1] &quot;Traitement terminé !&quot; ## setosa versicolor virginica ## 50 50 50 ## [1] &quot;Traitement terminé !&quot; 7.3.2 La boucle while La particularité de la boucle while réside dans la condition qui est testée à chaque itération. La boucle s’arrête lorsque la condition retourne FALSE. Cela signifie aussi qu’il faut créer un objet qu’on incrémentera au fur et à mesure afin d’éviter de générer une boucle infinie. i &lt;- 1 noms &lt;- c(&quot;Pierre&quot;,&quot;Paul&quot;,&quot;Jacques&quot;) while( i &lt;= length(noms)) { print(paste(&quot;Salut &quot;, noms[i])) print(&quot;Traitement terminé !&quot;) i &lt;- i + 1 } ## [1] &quot;Salut Pierre&quot; ## [1] &quot;Traitement terminé !&quot; ## [1] &quot;Salut Paul&quot; ## [1] &quot;Traitement terminé !&quot; ## [1] &quot;Salut Jacques&quot; ## [1] &quot;Traitement terminé !&quot; print(i) # &gt; à length(noms) donc la boucle est terminée ## [1] 4 i &lt;- 1 while ( i &lt;= ncol(iris)) { print(summary(iris[,i])) print(&quot;Traitement terminé !&quot;) i &lt;- i + 1 } ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 ## [1] &quot;Traitement terminé !&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.000 2.800 3.000 3.057 3.300 4.400 ## [1] &quot;Traitement terminé !&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 1.600 4.350 3.758 5.100 6.900 ## [1] &quot;Traitement terminé !&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.100 0.300 1.300 1.199 1.800 2.500 ## [1] &quot;Traitement terminé !&quot; ## setosa versicolor virginica ## 50 50 50 ## [1] &quot;Traitement terminé !&quot; print(i) # &gt; à ncol(iris) donc la boucle est terminée ## [1] 6 7.4 Exercice 7.4.1 Sujet Dans cet exercice, on utilise le fichier starwars qui décrit les caractéristiques des personnes principaux de la saga. Le dataset starwars.csv décrit les caractéristiques des personnages principaux de la saga. Voici un extrait du dataset : Importez le fichier starwars.csv Construisez une fonction appelée build_plot qui prend en entrée un vecteur s’il est de type numérique la fonction affiche un diagramme en boîte et retourne un résumé du vecteur s’il n’est pas de type numérique et présente 15 modalités différentes ou moins, la fonction affiche un diagramme en barre et retourne un résumé du vecteur sinon, la fonction n’affiche rien et retourne uniquement “Pas de traitement” Créez une boucle qui parcourt toutes les colonnes du data frame en appliquant la fonction build_plot pour chacune. 7.4.2 Correction Importez le fichier starwars.csv starWars &lt;- read.csv(&quot;./dataset/starwars.csv&quot;, sep = &quot;\\t&quot;) Construisez une fonction appelée build_plot qui prend en entrée un vecteur s’il est de type numérique la fonction affiche un diagramme en boîte et retourne un résumé du vecteur s’il n’est pas de type numérique et présente 15 modalités différentes ou moins, la fonction affiche un diagramme en barre et retourne un résumé du vecteur sinon, la fonction n’affiche rien et retourne uniquement “Pas de traitement” build_plot &lt;- function(x) { if (is.numeric(x)) { boxplot(x) return(summary(x)) } else if (length(unique(x)) &lt;= 15) { barplot(sort(table(x))) return(summary(x)) } else return(&quot;Pas de traitement&quot;) } Créez une boucle qui parcourt toutes les colonnes du data frame en appliquant la fonction build_plot pour chacune. for (i in starWars) { build_plot(x = i) } 7.5 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. "],
["apply.html", "Chapitre 8 Les fonctions apply 8.1 Fonction apply 8.2 Fonction lapply 8.3 Fonction sapply 8.4 Fonction tapply 8.5 Exercice", " Chapitre 8 Les fonctions apply La famille des fonctions apply est intégrée dans le package base déjà chargé en mémoire dans RStudio. Ces fonctions évitent d’avoir recours aux boucles. Dans ce TP, nous aborderons uniquement les fonctions apply, lapply et tapply. Mais, il en existe d’autres telles que sapply, mapply, vapply, etc. 8.1 Fonction apply La fonction apply est la fonction de base des fonctions de cette famille. Elle est utile pour appliquer une fonction sur chaque colonne d’une matrice. L’argument MARGIN permet de préciser si on veut appliquer la fonction mean pour chaque ligne ou chaque colonne. Ici l’objet X convertit le data frame en matrice, c’est pourquoi la fonction apply renvoie que des vecteurs de type character. apply(X = iris, MARGIN = 2, FUN = class) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; apply(X = iris[, 1:4], MARGIN = 2, FUN = mean) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 5.843333 3.057333 3.758000 1.199333 8.2 Fonction lapply La fonction lapply se construit de la même façon que la fonction apply à l’exception que le résultat renvoyé est une liste La fonction lapply prend en entrée une liste, un vecteur ou un data frame / matrice contrairement à la fonction apply. lapply(X = iris , function(x) class(x)) ## $Sepal.Length ## [1] &quot;numeric&quot; ## ## $Sepal.Width ## [1] &quot;numeric&quot; ## ## $Petal.Length ## [1] &quot;numeric&quot; ## ## $Petal.Width ## [1] &quot;numeric&quot; ## ## $Species ## [1] &quot;factor&quot; lapply(X = colnames(iris) , function(x) summary(iris[,x])) ## [[1]] ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 ## ## [[2]] ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.000 2.800 3.000 3.057 3.300 4.400 ## ## [[3]] ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 1.600 4.350 3.758 5.100 6.900 ## ## [[4]] ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.100 0.300 1.300 1.199 1.800 2.500 ## ## [[5]] ## setosa versicolor virginica ## 50 50 50 Quand on regarde de plus près, on se rend compte, que ces fonctions peuvent jouer le même rôle qu’une boucle. lapply(X = colnames(iris) , function(x) x) ## [[1]] ## [1] &quot;Sepal.Length&quot; ## ## [[2]] ## [1] &quot;Sepal.Width&quot; ## ## [[3]] ## [1] &quot;Petal.Length&quot; ## ## [[4]] ## [1] &quot;Petal.Width&quot; ## ## [[5]] ## [1] &quot;Species&quot; 8.3 Fonction sapply La fonction sapply est similaire à la fonction lapply sauf qu’elle ne retourne pas de liste mais un vecteur ou une matrice. sapply(X = iris , function(x) class(x)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;factor&quot; 8.4 Fonction tapply La fonction tapply adopte la même approche que la fonction aggregate. Elle permet d’agréger des données. Les arguments de la fonction d’agrégation sont renseignés dans la fonction tapply et non dans la fonction d’agrégation. tapply(X = iris$Sepal.Length, INDEX = iris$Species, FUN = mean, na.rm = TRUE) ## setosa versicolor virginica ## 5.006 5.936 6.588 8.5 Exercice 8.5.1 Sujet Calculez le taille moyenne pour chaque race de personnage Star Wars (species) Appliquez la fonction build_plot sur le data frame Star Wars en utilisant la fonction lapply. Calculer la moyenne de chaque variable numérique en utilisant la fonction sapply et lapply. 8.5.2 Correction Calculez le taille moyenne pour chaque race de personnage Star Wars (species) tapply(X = starWars$height, INDEX = starWars$species, FUN = mean, na.rm = TRUE) Appliquez la fonction build_plot sur le data frame Star Wars en utilisant la fonction lapply. lapply(X = starWars, function(x) build_plot(x)) Calculer la moyenne de chaque variable numérique en utilisant la fonction sapply et lapply. col_numeric &lt;- sapply(X = starWars, function(x) is.numeric(x)) lapply(X = starWars[ ,col_numeric], function(x) mean(x, na.rm = TRUE)) "],
["dplyr.html", "Chapitre 9 Manipuler les données avec dplyr 9.1 La fonction slice 9.2 La fonction filter 9.3 La fonction select 9.4 La fonction arrange 9.5 Enchaîner les fonctions avec le pipe 9.6 La fonction group_by 9.7 La fonction summarise 9.8 Autres fonctions utiles de dplyr", " Chapitre 9 Manipuler les données avec dplyr Certaines parties de ce chapitre sont extraites du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) Le package dplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables. Elle propose une syntaxe claire et cohérente. Ses fonctions sont en général plus rapides que leur équivalent sous R de base, elles permettent donc de traiter efficacement des données de grande dimension. Les fonctions de ce package peuvent s’appliquer à des tableaux de type data.frame ou tibble (package tibble de tidyverse), et elles retournent systématiquement un `tibble. Dans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables : flights contient des informations sur les vols : date, départ, destination, horaires, retard… year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest air_time distance hour minute time_hour 2013 1 1 517 515 2 830 819 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2013-01-01T10:00:00Z 2013 1 1 533 529 4 850 830 20 UA 1714 N24211 LGA IAH 227 1416 5 29 2013-01-01T10:00:00Z 2013 1 1 542 540 2 923 850 33 AA 1141 N619AA JFK MIA 160 1089 5 40 2013-01-01T10:00:00Z 2013 1 1 544 545 -1 1004 1022 -18 B6 725 N804JB JFK BQN 183 1576 5 45 2013-01-01T10:00:00Z 2013 1 1 554 600 -6 812 837 -25 DL 461 N668DN LGA ATL 116 762 6 0 2013-01-01T11:00:00Z 2013 1 1 554 558 -4 740 728 12 UA 1696 N39463 EWR ORD 150 719 5 58 2013-01-01T10:00:00Z 2013 1 1 555 600 -5 913 854 19 B6 507 N516JB EWR FLL 158 1065 6 0 2013-01-01T11:00:00Z 2013 1 1 557 600 -3 709 723 -14 EV 5708 N829AS LGA IAD 53 229 6 0 2013-01-01T11:00:00Z 2013 1 1 557 600 -3 838 846 -8 B6 79 N593JB JFK MCO 140 944 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 753 745 8 AA 301 N3ALAA LGA ORD 138 733 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 849 851 -2 B6 49 N793JB JFK PBI 149 1028 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 853 856 -3 B6 71 N657JB JFK TPA 158 1005 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 924 917 7 UA 194 N29129 JFK LAX 345 2475 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 923 937 -14 UA 1124 N53441 EWR SFO 361 2565 6 0 2013-01-01T11:00:00Z 2013 1 1 559 600 -1 941 910 31 AA 707 N3DUAA LGA DFW 257 1389 6 0 2013-01-01T11:00:00Z 2013 1 1 559 559 0 702 706 -4 B6 1806 N708JB JFK BOS 44 187 5 59 2013-01-01T10:00:00Z 2013 1 1 559 600 -1 854 902 -8 UA 1187 N76515 EWR LAS 337 2227 6 0 2013-01-01T11:00:00Z 2013 1 1 600 600 0 851 858 -7 B6 371 N595JB LGA FLL 152 1076 6 0 2013-01-01T11:00:00Z 2013 1 1 600 600 0 837 825 12 MQ 4650 N542MQ LGA ATL 134 762 6 0 2013-01-01T11:00:00Z 2013 1 1 601 600 1 844 850 -6 B6 343 N644JB EWR PBI 147 1023 6 0 2013-01-01T11:00:00Z airports contient des informations sur les aéroports faa name lat lon alt tz dst tzone 04G Lansdowne Airport 41.13047 -80.61958 1044 -5 A America/New_York 06A Moton Field Municipal Airport 32.46057 -85.68003 264 -6 A America/Chicago 06C Schaumburg Regional 41.98934 -88.10124 801 -6 A America/Chicago 06N Randall Airport 41.43191 -74.39156 523 -5 A America/New_York 09J Jekyll Island Airport 31.07447 -81.42778 11 -5 A America/New_York 0A9 Elizabethton Municipal Airport 36.37122 -82.17342 1593 -5 A America/New_York 0G6 Williams County Airport 41.46731 -84.50678 730 -5 A America/New_York 0G7 Finger Lakes Regional Airport 42.88356 -76.78123 492 -5 A America/New_York 0P2 Shoestring Aviation Airfield 39.79482 -76.64719 1000 -5 U America/New_York 0S9 Jefferson County Intl 48.05381 -122.81064 108 -8 A America/Los_Angeles 0W3 Harford County Airport 39.56684 -76.20240 409 -5 A America/New_York 10C Galt Field Airport 42.40289 -88.37511 875 -6 U America/Chicago 17G Port Bucyrus-Crawford County Airport 40.78156 -82.97481 1003 -5 A America/New_York 19A Jackson County Airport 34.17586 -83.56160 951 -5 U America/New_York 1A3 Martin Campbell Field Airport 35.01581 -84.34683 1789 -5 A America/New_York 1B9 Mansfield Municipal 42.00013 -71.19677 122 -5 A America/New_York 1C9 Frazier Lake Airpark 54.01333 -124.76833 152 -8 A America/Vancouver 1CS Clow International Airport 41.69597 -88.12923 670 -6 U America/Chicago 1G3 Kent State Airport 41.15139 -81.41511 1134 -5 A America/New_York 1G4 Grand Canyon West Airport 35.89990 -113.81567 4813 -7 A America/Phoenix airlines contient des données sur les compagnies aériennes carrier name 9E Endeavor Air Inc. AA American Airlines Inc. AS Alaska Airlines Inc. B6 JetBlue Airways DL Delta Air Lines Inc. EV ExpressJet Airlines Inc. F9 Frontier Airlines Inc. FL AirTran Airways Corporation HA Hawaiian Airlines Inc. MQ Envoy Air OO SkyWest Airlines Inc. UA United Air Lines Inc. US US Airways Inc. VX Virgin America WN Southwest Airlines Co. YV Mesa Airlines Inc. On va charger les trois tables du jeu de données : library(nycflights13) Trois objets correspondant aux trois tables ont dû apparaître dans votre environnement. On charge le package dplyr : library(dplyr) 9.1 La fonction slice La fonction slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres. Si on souhaite sélectionner la 345e ligne du tableau airports : slice(airports, 345) Si on veut sélectionner les 5 premières lignes : slice(airports, 1:5) 9.2 La fonction filter La fonction filter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE sont conservées. Par exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante : filter(flights, month == 1) Si on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes : filter(flights, dep_delay &gt;= 10 &amp; dep_delay &lt;= 15) On peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols avec la plus grande distance : filter(flights, distance == max(distance)) 9.3 La fonction select La fonction select permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports : select(airports, lat, lon) Si on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée : select(airports, -lat, -lon) La syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses : select(flights, year:day) select peut être utilisée pour réordonner les colonnes d’une table en utilisant la fonction everything(), qui sélectionne l’ensemble des colonnes non encore sélectionnées. Ainsi, si on souhaite faire passer la colonne name en première position de la table airports, on peut faire : select(airports, name, everything()) 9.4 La fonction arrange La fonction arrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes. Ainsi, si on veut trier le tableau flights selon le retard au départ croissant : arrange(flights, dep_delay) On peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ : arrange(flights, month, dep_delay) Si on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() : arrange(flights, desc(dep_delay)) 9.5 Enchaîner les fonctions avec le pipe Quand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc. Quand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” : arrange(select(filter(flights, dest == &quot;LAX&quot;), dep_delay, arr_delay), dep_delay) Cette notation a plusieurs inconvénients : elle est peu lisible les opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier. Il est difficile de voir quel paramètre se rapporte à quelle fonction Une autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire : tmp &lt;- filter(flights, dest == &quot;LAX&quot;) tmp &lt;- select(tmp, dep_delay, arr_delay) arrange(tmp, dep_delay) C’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin. Pour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe8. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr). Ainsi les deux expressions suivantes sont rigoureusement équivalentes : filter(flights, dest == &quot;LAX&quot;) flights %&gt;% filter(dest == &quot;LAX&quot;) Ce qui est intéressant dans cette histoire, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire : select(filter(flights, dest == &quot;LAX&quot;), dep_delay, arr_delay) On va pouvoir faire : flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) Si la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne. À chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select. Le résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire. Évidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. Par exemple, on peut stocker le résultat du pipeline dans un nouvel objet. L’utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. 9.6 La fonction group_by Un élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois : flights %&gt;% group_by(month) Par défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les fonctions comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations. Par exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau : flights %&gt;% group_by(month) %&gt;% slice(1) On peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. flights %&gt;% group_by(month, dest) 9.7 La fonction summarise La fonction summarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights : flights %&gt;% summarise(retard_dep = mean(dep_delay, na.rm=TRUE), retard_arr = mean(arr_delay, na.rm=TRUE)) Cette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire : flights %&gt;% group_by(month) %&gt;% summarise(max_delay = max(dep_delay, na.rm=TRUE), min_delay = min(dep_delay, na.rm=TRUE), mean_delay = mean(dep_delay, na.rm=TRUE), nb = n()) summarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. help(summarise) 9.8 Autres fonctions utiles de dplyr 9.8.1 La fonction rename La fonction rename permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude : rename(airports, longitude = lon, latitude = lat) Même si cela est déconseillé, si les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) : tmp &lt;- rename(flights, &quot;retard départ&quot; = dep_delay, &quot;retard arrivée&quot; = arr_delay) select(tmp, `retard départ`, `retard arrivée`) 9.8.2 La fonction mutate La fonction mutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes. Par exemple, la table flights contient la durée du vol en minutes. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire : flights &lt;- mutate(flights, duree_h = air_time / 60) select(flights, air_time, duree_h) On peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h. flights &lt;- mutate(flights, duree_h = air_time / 60, distance_km = distance / 0.62137, vitesse = distance_km / duree_h) select(flights, air_time, duree_h, distance, distance_km, vitesse) À noter que mutate est évidemment parfaitement compatible avec les fonctions de recodages comme case_when. flights &lt;- mutate(flights, type_retard = case_when( dep_delay &gt; 0 &amp; arr_delay &gt; 0 ~ &quot;Retard départ et arrivée&quot;, dep_delay &gt; 0 &amp; arr_delay &lt;= 0 ~ &quot;Retard départ&quot;, dep_delay &lt;= 0 &amp; arr_delay &gt; 0 ~ &quot;Retard arrivée&quot;, TRUE ~ &quot;Aucun retard&quot;)) 9.8.3 La fonction distinct La fonction distinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double. flights %&gt;% select(day, month) %&gt;% distinct On peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct ne conservera que la première d’entre elles. flights %&gt;% distinct(month, day) 9.8.4 La fonction case_when La fonction case_when est une généralisation de la fonction if_else(du package dplyr) ou ifelse (du package de base) qui permet d’indiquer plusieurs tests et leurs valeurs associées. flights &lt;- mutate(flights, type_retard = case_when( dep_delay &gt; 0 &amp; arr_delay &gt; 0 ~ &quot;Retard départ et arrivée&quot;, dep_delay &gt; 0 &amp; arr_delay &lt;= 0 ~ &quot;Retard départ&quot;, dep_delay &lt;= 0 &amp; arr_delay &gt; 0 ~ &quot;Retard arrivée&quot;, TRUE ~ &quot;Aucun retard&quot;)) select(flights, dep_delay, arr_delay , type_retard) Le pipe a été introduit à l’origine par le package magrittr, et repris par dplyr↩︎ "],
["chaines.html", "Chapitre 10 Manipuler le texte et les dates 10.1 Manipulation des chaînes de caractères 10.2 Manipulation des dates 10.3 Testez vos connaissances !", " Chapitre 10 Manipuler le texte et les dates 10.1 Manipulation des chaînes de caractères La manipulation des chaines de caractères est essentielle dans le traitement des données. On peut trouver des données textuelles sur réseaux sociaux par exemple. La plupart du temps, ces données sont brutes et il faut donc manipuler le texte pour en extraire les informations importantes. Pour manipuler des chaines de caractères, il faut bien entendu que les données soit de type caractère. On peut vérifier cela avec la fonction class() et as.character() si une conversion est nécessaire. x &lt;- c(&quot;Luca&quot;,&quot;Ambra&quot;,&quot;Francesco&quot;) class(x) ## [1] &quot;character&quot; 10.1.1 Concaténer des chaînes La fonction paste() permet de concaténer des chaînes de caractères. paste(c(&quot;Hello&quot;), c(&quot;Luca&quot;,&quot;Ambra&quot;,&quot;Francesco&quot;), sep = &quot;_&quot;) ## [1] &quot;Hello_Luca&quot; &quot;Hello_Ambra&quot; &quot;Hello_Francesco&quot; Ici, on profite du phénomène de réplication de R pour éviter de répéter le premier vecteur. On peut aussi utiliser la fonction cat() qui à le même rôle que la fonction print(). cat(&quot;Bonjour&quot;, &quot;\\n&quot; ,&quot;Une nouvelle ligne&quot;,&quot;\\n&quot; ,&quot;\\t&quot;, &quot;une tabulation&quot;, &quot;\\n&quot;, &quot;\\&quot;&quot;, &quot;une expression entre guillemets&quot;,&quot;\\&quot;&quot;) ## Bonjour ## Une nouvelle ligne ## une tabulation ## &quot; une expression entre guillemets &quot; Des caractères d’échapement sont présents dans l’exemple précédent. On peut en recontrer d’autres mais les plus fréquents sont le retour à la ligne \\n, souvent utilisé dans des titres de graphique et la tabulation \\t permettant notament d’importer des données quand le séparateur correspond à ce dernier. 10.1.2 Majuscule et minuscule Les fonctions toupper() et toloweer() permettent de modifier la casse. Rappelons que le langage R en est sensible tout comme la plupart des langages de programmation. toupper(x) ## [1] &quot;LUCA&quot; &quot;AMBRA&quot; &quot;FRANCESCO&quot; tolower(x) ## [1] &quot;luca&quot; &quot;ambra&quot; &quot;francesco&quot; 10.1.3 Longueur d’une chaîne On peut utiliser la fonction nchar() pour compter la longueur d’une chaîne. Attention, l’espace est considéré comme un caractère. nchar(x) ## [1] 4 5 9 10.1.4 Extraction de sous-chaînes La fonction substr() permet d’extraire certains élèments d’une chaîne de caractère à partir de leur position. substr(x,start = 1,stop = 3) ## [1] &quot;Luc&quot; &quot;Amb&quot; &quot;Fra&quot; Pour extraire la fin d’une chaîne de catactère, il est recommandé d’utiliser le package stringr avec la fonction str_sub(). library(stringr) str_sub(string = x,start = -3,end = -1) ## [1] &quot;uca&quot; &quot;bra&quot; &quot;sco&quot; 10.1.5 Remplacement de chaînes La fonction gsub() permet de remplacer un motif recherché par une autre chaîne de caractère. x &lt;- paste(c(&quot;Hello&quot;), c(&quot;Luca&quot;,&quot;Ambra&quot;,&quot;Francesco&quot;), sep = &quot;_&quot;) x ## [1] &quot;Hello_Luca&quot; &quot;Hello_Ambra&quot; &quot;Hello_Francesco&quot; x &lt;- gsub(pattern = &quot;_&quot;,replacement = &quot; &quot;,x) x ## [1] &quot;Hello Luca&quot; &quot;Hello Ambra&quot; &quot;Hello Francesco&quot; 10.1.6 Décomposition d’une chaîne On utilise la fonction strsplit() pour décomposer une chaîne de caractère selon un motif. Le résultat renvoyé est une liste. strsplit(x,split = &quot; &quot;) ## [[1]] ## [1] &quot;Hello&quot; &quot;Luca&quot; ## ## [[2]] ## [1] &quot;Hello&quot; &quot;Ambra&quot; ## ## [[3]] ## [1] &quot;Hello&quot; &quot;Francesco&quot; 10.1.7 Recherche de sous-chaîne La fonction grep() permet de rechercher les élèments d’un vecteur composé du motif. x ## [1] &quot;Hello Luca&quot; &quot;Hello Ambra&quot; &quot;Hello Francesco&quot; grep(pattern = &quot;Am&quot;, x) ## [1] 2 La fonction grepl() plus utile, permet de renvoyer TRUE ou FALSE si le motif est présent dans la chaîne. x ## [1] &quot;Hello Luca&quot; &quot;Hello Ambra&quot; &quot;Hello Francesco&quot; grepl(pattern = &quot;Am&quot;, x) ## [1] FALSE TRUE FALSE 10.1.8 Aller plus loin Les fonctions que propose le package base permettent de couvrir l’essentiel des méthodes de traitement de texte. Néanmoins, le package stringr de la suite tidyverse propose des fonctionnalités bien plus avancées. Julien Barnier en propose une immersion dans son tutoriel (vers le tutoriel). Il est possible d’utiliser des expressions régulières lorsqu’on utilise des fonctions de traitements de texte. Ricco Rakotomalala en propose d’ailleurs une esquisse dans son tutoriel. Voici un petit exemple de vérification d’adresse mail à partir d’une expression régulière : emails &lt;- c(&quot;steve_aoki@gmail.com&quot;, &quot;@jdoreofficiel&quot;, &quot;castex_jean@gouv.fr&quot;) regex &lt;- &quot;^[[:alnum:].-_]+@[[:alnum:].-]+$&quot; stringr::str_match(emails, regex) ## [,1] ## [1,] &quot;steve_aoki@gmail.com&quot; ## [2,] NA ## [3,] &quot;castex_jean@gouv.fr&quot; 10.2 Manipulation des dates 10.2.1 Les dates Les dates sont stockées comme le nombre de jours depuis 1970-01-01, avec des valeurs négatives pour les dates antérieures. Par défaut, R reconnait le format date si la chaîne de caractère est sous la forme yyyy-mm-dd. Néanmoins, lorsque ce n’est pas le cas on utilsie la fonction as.Date() qui convertit une chaîne de caractères en date. d &lt;- as.Date(&quot;2018-07-15&quot;) class(d) ## [1] &quot;Date&quot; unclass(d) ## [1] 17727 Dans l’exemple ci-dessus, cela fonctionne très bien car la chaîne de caractère correspond parfaitement au format interpréter par défaut de R. Lorsque ce n’est pas le cas, il faut indiquer à R comment interpréter la chaîne de caractère en tant que date. On utilise la table de référence présente dans l’aide en executant la commande help(strptime). d &lt;- as.Date(&quot;2018 15 07&quot;, format = (&quot;%Y %d %m&quot;)) d ## [1] &quot;2018-07-15&quot; d &lt;- as.Date(&quot;15 Juillet, 2018&quot;, format = (&quot;%d %B, %Y&quot;)) d ## [1] &quot;2018-07-15&quot; Voici un tableau récapitulatif : Ce tableau permet donc également de gérer le temps (heures, minutes, secondes) quand ces valeurs sont renseignées dans une chaîne de caractères. 10.2.2 L’horloge Le classe POSIXct est une des classes date pouvant gérer la date et l’horloge. Cette classe stocke les dates en secondes depuis 1970-01-01 01:00:00 d &lt;- as.POSIXct(&quot;2018-07-15 19:00:00&quot;) unclass(d) ## [1] 1531674000 ## attr(,&quot;tzone&quot;) ## [1] &quot;&quot; unclass(as.POSIXct(&quot;1970-01-01 01:00:00&quot;)) ## [1] 0 ## attr(,&quot;tzone&quot;) ## [1] &quot;&quot; La classe POSIXlt stocke la date et l’horloge sous forme de liste dont les éléments correspondent. Attention, ici l’année de référence semble être l’année 1900. d &lt;- as.POSIXlt(&quot;2018-07-15 19:00:00&quot;) unlist(unclass(d)) ## sec min hour mday mon year wday yday isdst zone ## &quot;0&quot; &quot;0&quot; &quot;19&quot; &quot;15&quot; &quot;6&quot; &quot;118&quot; &quot;0&quot; &quot;195&quot; &quot;1&quot; &quot;CEST&quot; ## gmtoff ## NA d$hour ## [1] 19 d$year ## [1] 118 Dans le cas où la chaîne de caractère ne respectère pas le format par défaut. On utilise le même procédé que pour la classe date. d &lt;- as.POSIXct(&quot;2018 15 07 190000&quot;, format = (&quot;%Y %d %m %H%M%S&quot;)) d ## [1] &quot;2018-07-15 19:00:00 CEST&quot; d &lt;- as.POSIXlt(&quot;15 Juillet, 2018 à 19h00 et 00s&quot;, format = (&quot;%d %B, %Y à %Hh%M et %Ss&quot;)) d ## [1] &quot;2018-07-15 19:00:00 CEST&quot; 10.2.3 Calcul sur les dates La fonction difftime() permet de calculer une différence entre deux dates. On peut s’en servir par exemple pour calculer un temps d’execution d’un programme. help(difftime) debut &lt;- Sys.time() Sys.sleep(5) fin &lt;- Sys.time() difftime(time1 = fin, time2 = debut,units = &quot;secs&quot;) ## Time difference of 5.009003 secs 10.2.4 Aller plus loin Le package lubridate propose des fonctionnalités plus avancées pour la manipulation des dates et des calendrier que ne savent pas gérer les fonctions par défaut de R. 10.3 Testez vos connaissances ! Testez vos connaissances sur ce chapitre avec ce quiz (10 min) en cliquant ici. "],
["jointures.html", "Chapitre 11 Jointures9 11.1 Principe 11.2 Types de jointures 11.3 Exercice", " Chapitre 11 Jointures9 11.1 Principe Les jointures permettent d’associer plusieurs tables dans une même requête. Cela permet d’exploiter la puissance des bases de données relationnelles pour obtenir des résultats qui combinent les données de plusieurs tables de manière efficace. En général, les jointures consistent à associer des lignes de 2 tables en associant l’égalité des valeurs d’une colonne d’une première table par rapport à la valeur d’une colonne d’une seconde table. Imaginons qu’une base de 2 données possède une table “utilisateur” et une autre table “abonnement” qui contient des informations sur les comptes de ces utilisateurs. Voici la table utilisateur : Id_utilisateur Name Age 1 Luca 18 2 Martin 20 3 Mélanie 22 4 François 21 Voici la table abonnement : Id_utilisateur Like Share 1 24 5 2 66 0 4 8 11 5 34 27 Imaginons qu’une base de 2 données possède une table “utilisateur” et une autre table “abonnement” qui contient les informations du nombre de pages aimées et partagées de ces utilisateurs. Avec une jointure, il est possible d’obtenir les données des deux tables. 11.2 Types de jointures Il y a plusieurs types de jointures pour associer 2 tables ensemble. Voici la liste des 4 principales : INNER JOIN : jointure interne pour retourner les enregistrements quand la condition est vrai dans les 2 tables. C’est l’une des jointures les plus communes. LEFT JOIN (ou LEFT OUTER JOIN) : jointure externe pour retourner tous les enregistrements de la table de gauche (LEFT = gauche) même si la condition n’est pas vérifié dans l’autre table. RIGHT JOIN (ou RIGHT OUTER JOIN) : jointure externe pour retourner tous les enregistrements de la table de droite (RIGHT = droite) même si la condition n’est pas vérifié dans l’autre table. FULL JOIN (ou FULL OUTER JOIN) : jointure externe pour retourner les résultats quand la condition est vrai dans au moins une des 2 tables. La fonction merge (du package base chargé par défaut dans RStudio) permet de réaliser ces 4 types de jointures. Cette fonction admet différents arguments selon la structure des deux tables à joindre : x, y : le nom des deux tables à joindre by : le nom de la colonne commune jouant le rôle de clé primaire / étrangère by.x, by.y : le nom de chaque colonne jouant le rôle de clé primaire / étrangère si elles n’ont pas le même nom all : par défaut FALSE pour réaliser une inner join, TRUE pour une full join all.x : par défaut FALSE, TRUE pour réaliser une left join all.y : par défaut FALSE, TRUE pour réaliser une right join Le package dplyr permet également de réaliser des jointures avec les fonctions left_join, right_join, full_join, inner_join et d’aller plus loin. Les fonctions de jointure de dplyr ont un temps de traitement plus rapide que celles proposées par la fonction merge. Nous comparerons les deux méthodes dans la correction de l’exercice. 11.2.1 Left Join left &lt;- merge(x = Utilisateur, y = Abonnement, by = &quot;Id_utilisateur&quot;, all.x = TRUE) Id_utilisateur Name Age Like Share 1 Luca 18 24 5 2 Martin 20 66 0 3 Mélanie 22 NA NA 4 François 21 8 11 En réalisant une jointure externe gauche, on observe : qu’on retrouve les informations des deux tables pour les id_utilisateur 1,3 et 4. qu’on ne retrouve pas l’id_utilisateur 5 dans la table de sortie n’étant pas présent dans la table Utilisateur. la présence de NA pour l’id_utilisateur 3 car il n’etait pas présent dans la table Abonnement. 11.2.2 Right Join right &lt;- merge(x = Utilisateur, y = Abonnement, by = &quot;Id_utilisateur&quot;, all.y = TRUE) Id_utilisateur Name Age Like Share 1 Luca 18 24 5 2 Martin 20 66 0 4 François 21 8 11 5 NA NA 34 27 En réalisant une jointure externe droite, on observe : qu’on retrouve les informations des deux tables pour les id_utilisateur 1,2 et 4. qu’on ne retrouve pas l’id_utilisateur 3 dans la table de sortie n’étant pas présent dans la table Abonnement la présence de NA pour l’id_utilisateur 5 car il n’etait pas présent dans la table Utilisateur. 11.2.3 Inner Join inner &lt;- merge(x = Utilisateur, y = Abonnement, by = &quot;Id_utilisateur&quot;) Id_utilisateur Name Age Like Share 1 Luca 18 24 5 2 Martin 20 66 0 4 François 21 8 11 En réalisant une jointure interne, on observe : qu’on retrouve les informations des deux tables pour les id_utilisateur 1,2 et 4. qu’on ne retrouve pas l’id_utilisateur 3 et 5 dans la table de sortie n’étant pas présents dans l’une des deux tables. 11.2.4 Full Join full &lt;- merge(x = Utilisateur, y = Abonnement, by = &quot;Id_utilisateur&quot;, all = TRUE) Id_utilisateur Name Age Like Share 1 Luca 18 24 5 2 Martin 20 66 0 3 Mélanie 22 NA NA 4 François 21 8 11 5 NA NA 34 27 En réalisant une jointure externe, on observe : qu’on retrouve les informations des deux tables pour les id_utilisateur 1,2 et 4. la présence de NA pour l’id_utilisateur 3 et 5 n’étant pas présents dans l’une des deux tables. 11.3 Exercice Pour illustrer ces notions, on utilise la base de données nycflights13 du même package. La base de données est répartie en 5 tables et disponible à partir du package nycflights13 : table flights (336776 x 20) : une ligne décrit un vol table airlines (16 x 2) : une ligne décrit une compagnie table airports (1458 x 8) : une ligne décrit un aéroport table planes (3322 x 9) : une ligne décrit un appareil table weather (26115 x 15) : une ligne décrit les conditions météorologiques au départ d’un vol avec une mesure par heure Voici le modèle relationnel de ces 5 tables : 11.3.1 Sujet Affichez le nom des 3 compagnies avec le plus de vols. name nb_vols United Air Lines Inc. 58665 JetBlue Airways 54635 ExpressJet Airlines Inc. 54173 Affichez le nombre de vols à destination de chaque tzone (table airports). tzone nb_vols America/New_York 192377 America/Chicago 74811 America/Los_Angeles 46324 America/Denver 10291 NA 7602 America/Phoenix 4656 Pacific/Honolulu 707 America/Anchorage 8 On observe que la catégorie NA signifie que certaines destinations ne sont pas référencées dans la table airports. Dans quel aéroport y a-t-il le plus de précipitations ? origin precip_moy EWR 0.0050923 JFK 0.0037549 LGA 0.0042967 Pour obtenir ce résultat, on utilise la fonction distinct du package dplyr après la jointure. 11.3.2 Correction Affichez le nom des 3 compagnies avec le plus de vols. #jointure sans dplyr start.time &lt;- Sys.time() requete &lt;- merge(x = flights,y = airlines, by = &quot;carrier&quot;,all.x = TRUE) Sys.time() - start.time ## Time difference of 2.241998 secs #jointure avec dplyr start.time &lt;- Sys.time() requete &lt;- left_join(x = flights, y = airlines, by = &quot;carrier&quot;) ## Warning: Column `carrier` joining factor and character vector, coercing ## into character vector Sys.time() - start.time ## Time difference of 0.175997 secs requete %&gt;% group_by(name) %&gt;% summarise(nb_vols = n()) %&gt;% arrange(desc(nb_vols)) %&gt;% slice(1:3) %&gt;% kable() name nb_vols United Air Lines Inc. 58665 JetBlue Airways 54635 ExpressJet Airlines Inc. 54173 Affichez le nombre de vols à destination de chaque tzone (table airports). #jointure sans dplyr start.time &lt;- Sys.time() requete &lt;- merge(x = flights,y = airports[,c(&quot;faa&quot;,&quot;tzone&quot;)], by.x = &quot;dest&quot;, by.y = &quot;faa&quot;, all.x = TRUE) Sys.time() - start.time ## Time difference of 1.058514 secs #jointure avec dplyr start.time &lt;- Sys.time() requete &lt;- left_join(x = flights, y = select(airports, c(&quot;faa&quot;,&quot;tzone&quot;)), by = c(&quot;dest&quot; = &quot;faa&quot;)) ## Warning: Column `dest`/`faa` joining factor and character vector, coercing ## into character vector Sys.time() - start.time ## Time difference of 0.1639991 secs requete %&gt;% group_by(tzone) %&gt;% summarise(nb_vols = n()) %&gt;% arrange(desc(nb_vols)) %&gt;% kable() tzone nb_vols America/New_York 192377 America/Chicago 74811 America/Los_Angeles 46324 America/Denver 10291 NA 7602 America/Phoenix 4656 Pacific/Honolulu 707 America/Anchorage 8 On observe que la catégorie NA signifie que certaines destinations ne sont pas référencées dans la table airports. Dans quel aéroport y a-t-il le plus de précipitations ? #jointure sans dplyr start.time &lt;- Sys.time() requete &lt;- merge(x = flights, y = weather, by = c(&quot;year&quot; = &quot;year&quot;, &quot;month&quot; = &quot;month&quot;, &quot;day&quot; = &quot;day&quot;, &quot;hour&quot; = &quot;hour&quot; , &quot;origin&quot; = &quot;origin&quot;), all.x = TRUE) Sys.time() - start.time ## Time difference of 1.543527 secs #jointure avec dplyr start.time &lt;- Sys.time() requete &lt;- left_join(x = flights, y = weather, by = c(&quot;year&quot; = &quot;year&quot;, &quot;month&quot; = &quot;month&quot;, &quot;day&quot; = &quot;day&quot;, &quot;hour&quot; = &quot;hour&quot; , &quot;origin&quot; = &quot;origin&quot;)) ## Warning: Column `origin` joining factor and character vector, coercing into ## character vector Sys.time() - start.time ## Time difference of 0.1900928 secs requete %&gt;% select(year, month, day, hour, origin, origin, precip) %&gt;% distinct() %&gt;% group_by(origin) %&gt;% summarise(precip_moy = mean(precip,na.rm = TRUE)) %&gt;% kable() origin precip_moy EWR 0.0050923 JFK 0.0037549 LGA 0.0042967 Extrait du site sql.sh - https://sql.sh/cours/jointures↩︎ "],
["express.html", "Chapitre 12 R-Express 30’ ☕ 12.1 Aller hop ! Importez des données 12.2 Manipulez votre tableau 12.3 Des graphiques en 3 clics avec esquisse 12.4 En bref", " Chapitre 12 R-Express 30’ ☕ Il est peut être intéressant d’aborder ce chapitre en amont d’une formation Nous présentons ici comment être opérationnel sur R en quelques clics et surtout sans connaissance du langage ! Attention tout de même, vous ne pourrez pas faire illusion bien longtemps car il faudra revenir au fondamentaux du langage pour aller plus loin. Ici nous allons à droit au but. 30’ Top chrono ! 12.1 Aller hop ! Importez des données RStudio propose une interface permettant d’importer un fichier de données de manière interactive. Pour y accéder, dans l’onglet Environment, cliquez sur le bouton Import Dataset. On a ensuite le choix du format de fichier qu’on souhaite importer. Sélectionnez From Text (base)…. Une nouvelle fenêtre s’affiche : Il vous suffit d’indiquer le fichier à importer dans le champ File/URL tout en haut (vous pouvez même indiquer un lien vers un fichier distant via HTTP). Importez le fichier tv_shows.csv qui décrit les notes d’évaluation des films et séries disponibles sur diverses plateformes de diffusion en continu. Un aperçu s’ouvre dans la partie Data Preview et vous permet de vérifier si l’import est correct. Le champ Name qui est modifiable correspondra au nom de votre tableau dans RStudio. Cliquez ensuite sur Import. RStudio vous propose une vue de votre tableau. 12.2 Manipulez votre tableau 12.2.1 Dans une vue Après l’importation, vous pouvez accéder à la vue de votre tableau en cliquant sur votre objet dans la fenêtre d’environnement Vous pouvez ensuite effectuer des tris et des filtres en naviguant sur la vue. Dans l’exemple ci-dessous nous avons filtré sur l’année 2019, filtré les films disponibles sur Netflix et trié selon la note des utilisateurs en colonne IMDb. 12.2.2 Avec dplyr Bon le problème de manipuler un tableau dans une vue est qu’on ne peut pas le modifier. Pour cela, nous allons commencer à coder en R avec un package qui nous facilite la vie. Mais c’est quoi un package ? R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus de packages permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des packages sont développées et maintenues par la communauté des utilisateurs de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network). Pour installer un package, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Renseignez le nom du package dplyr dans le champ concerné puis cliquez sur Install. Cela peut durer quelques secondes. Voilà, vous avez enfin le package dplyr dans la liste des packages déjà installés. Nous n’aurons plus à réitérer cette opération les prochaines fois. Nous allons maintenant créer un script pour que toutes nos commandes soient sauvegardées et réutilisables. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script ou tout simplement utiliser le raccourci Ctrl + Shift + N. Voici la première commande que nous allons saisir. Même si le package dplyr est déjà installé, il faut que RStudio le charge en mémoire. Écrivez cette ligne dans votre script : library(dplyr) Vous avez écrit une ligne de commande mais il faut encore l’exécuter. Pour cela, sélectionnez votre code à exécuter puis cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée. On peut désormais utiliser les fonctionnalités du package dplyr. 12.2.3 Sélectionner certaines colonnes La fonction select permet de sélectionner certaines colonnes d’un tableau. On va construire un nouveau tableau appelé tv_shows_select avec uniquement les colonnes Title, Year, Age et IMDb. tv_shows_select &lt;- select(tv_shows, Title, Year, Age, IMDb) Title Year Age IMDb Breaking Bad 2008 18+ 9.5 Stranger Things 2016 16+ 8.8 Money Heist 2017 18+ 8.4 Sherlock 2010 16+ 9.1 Better Call Saul 2015 18+ 8.7 The Office 2005 16+ 8.9 Black Mirror 2011 18+ 8.8 Supernatural 2005 16+ 8.4 Peaky Blinders 2013 18+ 8.8 Avatar: The Last Airbender 2005 7+ 9.2 The Walking Dead 2010 18+ 8.2 Dark 2017 16+ 8.7 Ozark 2017 18+ 8.4 Attack on Titan 2013 16+ 8.8 Narcos 2015 18+ 8.8 Fullmetal Alchemist: Brotherhood 2009 18+ 9.1 Community 2009 7+ 8.5 Mindhunter 2017 18+ 8.6 Parks and Recreation 2009 16+ 8.6 Dexter 2006 18+ 8.6 Votre nouveau tableau apparaît dans la fenêtre Environnement. 12.2.4 Ajouter des filtres La fonction filter permet de construire des filtres. On va construire un nouveau tableau appelé tv_shows_filter en partant du tableau précédent. On ajoute un filtre sur la variable Year en ne conservant que les films de 2019. tv_shows_filter &lt;- filter(tv_shows_select, Year == 2019) Title Year Age IMDb The Witcher 2019 18+ 8.3 When They See Us 2019 18+ 8.9 After Life 2019 18+ 8.5 Dead to Me 2019 18+ 8.1 Unbelievable 2019 18+ 8.4 Sex Education 2019 16+ 8.3 Kingdom 2019 18+ 8.4 Love, Death &amp; Robots 2019 18+ 8.5 The Umbrella Academy 2019 16+ 7.9 Russian Doll 2019 18+ 7.9 Our Planet 2019 7+ 9.3 The Dark Crystal: Age of Resistance 2019 7+ 8.5 The Spy 2019 18+ 7.9 Crash Landing on You 2019 16+ 8.8 Delhi Crime 2019 NA 8.5 Don’t F**k with Cats: Hunting an Internet Killer 2019 18+ 8.1 Living with Yourself 2019 18+ 7.2 The Order 2019 18+ 6.9 Marianne 2019 18+ 7.5 The Society 2019 18+ 7.0 12.2.5 Trier un tableau La fonction arrange permet de construire des filtres. On va construire un nouveau tableau appelé tv_shows_sort en partant du tableau précédent. On tri les films de la meilleure note IMDb à la plus mauvaise. tv_shows_sort &lt;- arrange(tv_shows_filter, desc(IMDb)) Title Year Age IMDb Our Planet 2019 7+ 9.3 The Planets 2019 all 9.1 The Imagineering Story 2019 7+ 9.1 When They See Us 2019 18+ 8.9 The Untamed 2019 7+ 8.9 Vinland Saga 2019 NA 8.9 Crash Landing on You 2019 16+ 8.8 Demon Slayer: Kimetsu no Yaiba 2019 18+ 8.8 The Promised Neverland 2019 18+ 8.8 The Boys 2019 18+ 8.7 The Mandalorian 2019 7+ 8.7 Formula 1: Drive to Survive 2019 16+ 8.6 The Family Man 2019 16+ 8.6 Prairie Dog Manor 2019 NA 8.6 After Life 2019 18+ 8.5 Love, Death &amp; Robots 2019 18+ 8.5 The Dark Crystal: Age of Resistance 2019 7+ 8.5 Delhi Crime 2019 NA 8.5 Taco Chronicles 2019 7+ 8.5 The First 48 Presents: Homicide Squad Atlanta 2019 16+ 8.5 Après ces 3 opérations select, filter et arrange, vous devez avoir ces tableaux dans votre environnement. 12.3 Des graphiques en 3 clics avec esquisse Le package esquisse permet de construire des graphiques en quelques clics. Il faut aussi installer ce package, cette fois-ci on le fait directement en exécutant une seule et unique fois cette commande dans le script : install.packages(&quot;esquisse&quot;) Voilà, puis executer ces commandes : library(esquisse) esquisser(tv_shows_sort) Une fenêtre s’ouvre dans lequel vous pouvez construire quelques graphiques, les personnalisés et les exporter avec le code associé. 12.4 En bref Nous avons vu dans ce chapitre comment être opérationnel très rapidement sur R avec des commandes pratiques et faciles. Néanmoins, cela n’est pas suffisant pour aller plus loin. Ce cours vous fournira une base théorique permettant d’être autonome par la suite. "],
["entrainement.html", "Chapitre 13 S’entrainer 13.1 TP1 13.2 TP2 13.3 TP3 13.4 TP4 13.5 TP5 - Chercher l’erreur 13.6 TP6 - Analyses statistiques 13.7 TP7 - Analyse de film", " Chapitre 13 S’entrainer 13.1 TP1 Difficulté 🏆 Ce TP reprend les notions évoquées dans les chapitres 2 et 3. On utilise le dataset mtcars qui décrit les statistiques de voitures. Le dataset est présent dans le package datasets automatiquement installé sur R. Voici une description des données : mpg : Miles/(US) gallon cyl : Number of cylinders disp : Displacement (cu.in.) hp : Gross horsepower drat : Rear axle ratio wt : Weight (1000 lbs) qsec : 1/4 mile time vs : Engine (0 = V-shaped, 1 = straight) am : Transmission (0 = automatic, 1 = manual) gear : Number of forward gears carb : Number of carburetors mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Exercice 1 : Préparer son environnement de travail Dupliquer le dataset dans un nouvel objet appelé df. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ? Affichez le nom des colonnes Affichez le type des colonnes avec la fonction adaptée. On souhaite analyser les variables cyl, vs, am, gear et carb en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor. Combien de niveaux (levels) sont présents dans ces variables ? Affichez un résumé des données avec la fonction adaptée. Exercice 2 : Statistiques descriptives Déterminer la moyenne de la variable mpg Déterminer le maximum la variable wt. Déterminer la médiane de la variable hp. Déterminer les quartiles de la variable qsec. Déterminer les déciles de la variable qsec. Déterminer la variance et l’écart-type de la variable qsec. Déterminer un tri à plat pour compter les effectifs des modalités de chaque variables factor. Exercice 3 : Quelques graphiques Contruire un histogramme de la distribution de la variable qsec. Constuire une boîte à moustache de la distribution de la variable qsec. Construire un diagramme en barre de répartition de la variable carb. Construire un diagramme circulaire de la répartition de la variable vs. Exercice 4 : Création de nouvelles colonnes La colonne mpg correspond au nombre de miles parcouru en 1 gallon (US). Cette mesure correspond en quelques sortes à la mesure de consommation de litres aux 100 km utilisée en France. Créer une colonne supplémentaire appelée litres_au_100km qui correspond à la conversion de la variable mpg(Miles/(US) gallon) en nombre de litres aux 100 kilomètres. Aidez-vous du guide des conversion disponible sur ce lien. Construire une nouvelle colonne appelée qsec_cut qui est un découpage de la variable qsec en 3 groupes (pas de restriction sur le nombre de classe). Construire une nouvelle colonne appelée litres100km_group pour distinguer deux groupes de voiture : celles qui consomment plus que la moyenne et celles qui consomment moins que la moyenne. 13.2 TP2 Difficulté 🏆🏆 Ce TP reprend les notions évoquées dans les chapitres 2 à 5. On utilise le fichier pokemon.xlsx qui décrit les statistiques des pokemon des deux premières générations. Le fichier est issu du site Kaggle. Il a été adapté pour ce TP. Pour réaliser ce TP, télécharger le fichier en cliquant ici.Voici une description des données : pokedex_number : numéro du pokemon nom : nom du pokemon generation : le numéro de génération dont est issu le pokemon is_legendary : Oui / Non si le pokemon est légendaire type : le type du pokemon weight_kg : le poids du pokemon en kg height_m : la taille du pokemon en mètre attack : la puissance d’attaque du pokemon defense : la puissance de défense du pokemon speed : la vitesse du pokemon pokedex_number nom generation is_legendary type weight_kg height_m attack defense speed 1 Bulbizarre 1 Non grass 6.9 0.7 49 49 45 2 Herbizarre 1 Non grass 13.0 1.0 62 63 60 3 Florizarre 1 Non grass 100.0 2.0 100 123 80 4 Salameche 1 Non fire 8.5 0.6 52 43 65 5 Reptincel 1 Non fire 19.0 1.1 64 58 80 6 Dracaufeu 1 Non fire 90.5 1.7 104 78 100 7 Carapuce 1 Non water 9.0 0.5 48 65 43 8 Carabaffe 1 Non water 22.5 1.0 63 80 58 9 Tortank 1 Non water 85.5 1.6 103 120 78 10 Chenipan 1 Non bug 2.9 0.3 30 35 45 11 Chrysacier 1 Non bug 9.9 0.7 20 55 30 12 Papilusion 1 Non bug 32.0 1.1 45 50 70 13 Aspicot 1 Non bug 3.2 0.3 35 30 50 14 Coconfort 1 Non bug 10.0 0.6 25 50 35 15 Dardargnan 1 Non bug 29.5 1.0 150 40 145 16 Roucool 1 Non normal 1.8 0.3 45 40 56 17 Roucoups 1 Non normal 30.0 1.1 60 55 71 18 Roucarnage 1 Non normal 39.5 1.5 80 80 121 19 Rattata 1 Non normal NA NA 56 35 72 20 Rattatac 1 Non normal NA NA 71 70 77 Exercice 1 : Importer les données Importez le jeu de données pokemon.xlsx à l’aide du package readxl. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ? Affichez le nom des colonnes. Affichez le type des colonnes avec la fonction adaptée. On souhaite analyser les variables generation, is_legendary, et type en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor. Combien de niveaux (levels) sont présents dans ces variables ? Affichez un résumé des données avec la fonction adaptée. Exercice 2 : Statistiques descriptives Déterminer la moyenne de la variable weight_kg. Déterminer la médiane de la variable weight_kg. Déterminer les quartiles de la variable height_m. Déterminer les déciles de la variable height_m. Déterminer la variance et l’écart-type de la variable weight_kg. Déterminer un tri à plat pour compter les effectifs des modalités de chaque variable factor en triant chaque sortie par ordre décroissant. Exercice 3 : Tris et Selections Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Exemple : #Selectionnez les deux premières colonnes du data frame requete_0 &lt;- pokemon[,1:2] dim(requete_0) ## [1] 251 2 Sélectionnez la colonne nom et is_legendary. Sélectionnez les 50 premières lignes et les deux premières colonnes. Sélectionnez les 10 premières lignes et toutes les colonnes. Sélectionnez toutes les colonnes sauf la dernière. Sélectionnez les colonnes 2,8,9 et 10. Sélectionnez les lignes 20 à 30 et 80 à 100. Triez le dataset par ordre alphabétique et afficher le nom du pokemon dela première ligne. Triez le dataset par weight_kg en ordre décroissant, et afficher le nomdu pokemon de la première ligne Triez le dataset par attack en ordre décroissant puis par speed en ordre croissant, et afficher le nom des pokemons des 10 premières lignes. Exercice 4 : Tris et Filtres Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Pour faciliter la lecture, sélectionnez la colonne nomet les colonnes concernées par le filtre. Exemple : #Selectionnez les pokemons de type feu requete_0 &lt;- pokemon[ pokemon$type == &quot;fire&quot;, c(&quot;nom&quot;,&quot;type&quot;)] dim(requete_0) ## [1] 20 2 Filtrez sur les pokemons qui ont 150 ou plus d’attack puis trier le résultat par ordre décroissant d’attack. Filtrez sur les pokemons de type dragon,ghost,psychic et dark Filtrez sur les pokemons de type fire avec plus de 100 d’attack, puis trier le résultat par ordre décroissant d’attack. Filtrez sur les pokemons qui ont entre 100 et 150 de speed. Les trier par speed décroissant. Filtrez sur les pokemons pesant plus de 250 kg et affichez le résultat pour vérifier. Filtrez sur les pokémons qui ont des valeurs manquantes sur la variable height_m. Filtrez sur les pokemons qui ont des valeurs renseignées à la fois pour la variable weight_kg et la variable height. Exercice 5 : Agregations Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Exemple : #Calculez la vitesse moyenne par generation requete_0 &lt;- aggregate(formula = speed ~ generation, data = pokemon , FUN = mean) dim(requete_0) ## [1] 2 2 generation speed 1 70.15232 2 61.61000 Calculez l’attack moyenne en fonction de la variable type, puis filtrez sur les 3 types avec les moyennes les plus élevées. Calculez le nombre de pokemon par type , puis triez par ordre décroissant ces effectifs. Calculez la médiane de weight_kg par type. Calculez le nombre de pokemon par type et generation Calculez la moyenne de chaque critère (weight_kg, height_m, attack, defense et speed) en fonction de chaque type. 13.3 TP3 Difficulté 🏆🏆🏆 Ce TP reprend les notions évoquées dans les chapitres 6,7 et 10. On utilise le fichier compressé AmongUs.7z où l’ensemble des fichiers décrivent les statistiques des parties jouées sur le jeu Among Us. Il y a un fichier par joueur nommé UserX.csv. Les données sont issues du site Kaggle. Pour réaliser ce TP, télécharger le fichier en cliquant ici. Les fichiers csv ont tous la même structure avec : Game.Completed.Date : Date de la partie Team : l’équipe attribuée Outcome : résultat de la partie Task.Completed : le nombre de tâches effectuées All.Tasks.Completed : si toutes les tâches ont été effectuées Murdered : si le joueur a été tué Imposter.Kills : le nombre de joueurs tués par l’imposteur Game.Length : durée de la partie Ejected : si le joueur a été éliminé par les autres au cours de la partie Sabotages.Fixed : nombre de sabotages réparés Time.to.complete.all.tasks : temps pour compléter les toutes les tâches Rank.Change : Non renseigné Region.Game.Code : la région du serveur de jeu Game.Completed.Date Team Outcome Task.Completed All.Tasks.Completed Murdered Imposter.Kills Game.Length Ejected Sabotages.Fixed Time.to.complete.all.tasks Rank.Change Region.Game.Code 12/13/2020 at 1:26:56 am EST Crewmate Win 3 No Yes 07m 04s No 2 ++ NA / WYMSBF 12/13/2020 at 1:17:42 am EST Crewmate Loss 7 Yes No 16m 21s No 1 09m 48s – NA / WYMSBF 12/13/2020 at 12:57:47 am EST Crewmate Win 3 No No 11m 33s No 0 ++ NA / WYMSBF 12/13/2020 at 12:41:55 am EST Imposter Win 2 08m 05s No N/A +++ Europe / QIRTNF 12/13/2020 at 12:30:37 am EST Crewmate Loss 4 No No 05m 10s No 0 — Europe / QIRTNF 12/13/2020 at 12:24:20 am EST Crewmate Loss 7 Yes Yes 16m 22s No 0 12m 16s – Europe / QIRTNF 12/13/2020 at 12:00:39 am EST Crewmate Loss 8 Yes Yes 21m 41s No 1 18m 38s – Europe / MTKPVF 12/11/2020 at 4:15:08 pm EST Crewmate Win 8 Yes No 18m 43s Yes 0 07m 48s ++ Europe / BFRJCF 12/11/2020 at 3:49:33 pm EST Crewmate Win 7 Yes Yes 13m 15s No 0 13m 15s ++ Europe / BFRJCF 12/11/2020 at 3:30:36 pm EST Crewmate Loss 7 Yes Yes 12m 43s No 0 12m 43s – Europe / BFRJCF 12/11/2020 at 3:10:58 pm EST Crewmate Win 4 No Yes 11m 00s No 0 ++ Europe / BFRJCF 12/11/2020 at 2:53:28 pm EST Crewmate Win 7 Yes No 17m 43s No 0 11m 59s ++ Europe / BFRJCF 12/11/2020 at 2:20:38 pm EST Crewmate Loss 6 No Yes 13m 46s No 0 — Europe / ONSJWQ 12/11/2020 at 2:04:26 pm EST Imposter Loss 3 15m 52s Yes N/A Europe / ONSJWQ 12/11/2020 at 1:46:30 pm EST Crewmate Win 7 Yes Yes 18m 54s No 1 11m 09s ++ Europe / ONSJWQ 12/11/2020 at 2:09:32 am EST Crewmate Loss 7 Yes Yes 08m 00s No 0 01m 41s – NA / EYNONF 12/11/2020 at 2:00:26 am EST Crewmate Win 7 Yes Yes 18m 06s No 0 09m 34s ++ NA / EYNONF 12/11/2020 at 1:26:11 am EST Crewmate Win 7 Yes Yes 12m 58s No 1 09m 03s ++ NA / EYNONF 12/11/2020 at 1:03:05 am EST Crewmate Win 7 Yes Yes 14m 57s No 0 14m 50s ++ NA / EYNONF 12/11/2020 at 12:45:34 am EST Crewmate Loss 7 Yes Yes 11m 03s No 0 10m 34s – NA / EYNONF Exercice 1 : Créer le jeu de données Télécharger le fichier compressé AmongUs.7z et le déziper. La fonction list.files() devrait vous aider à extraire l’ensemble des noms de fichiers présents dans un répertoire (voir l’exemple ci-dessous). list.files(path = &quot;dataset/&quot;, pattern=&quot;*.csv&quot;, full.names=FALSE) ## [1] &quot;AmongUs.csv&quot; &quot;flights.csv&quot; &quot;google.csv&quot; ## [4] &quot;NBA.csv&quot; &quot;planes.csv&quot; &quot;starwars.csv&quot; ## [7] &quot;students_results.csv&quot; &quot;Titanic.csv&quot; &quot;tv_shows.csv&quot; Compiler l’ensemble des fichiers UserX.csv présents dans le fichier zip dans un seul et même data frame. Utiliser une boucle qui parcourt chaque fichier csv utilisateur. La fonction rbind() devrait vous aider à compiler les différents csv dans un seul data frame (voir l’exemple ci-dessous). 📢 Attention, pour le bon déroulement du TP, intégrer l’argument stringsAsFactors = FALSE dans votre fonction read.csv(). Cet argument permet de ne pas typer par défaut les variables character en factor lors de l’importation. df &lt;- data.frame() dim(df) ## [1] 0 0 df &lt;- rbind(df, mtcars) dim(df) ## [1] 32 11 df &lt;- rbind(df, mtcars) dim(df) ## [1] 64 11 Modifier votre boucle afin d’ajouter une colonne dans le data frame final qui renseigne le numéro d’utilisateur disponible dans le nom de chaque fichier csv. 💡 indice : Il est plus simple d’ajouter une colonne avec le nom du fichier juste avant la fonction rbind(). Stocker le data frame final dans un objet appelé AmongUs. Supprimer la colonne Rank.Change qui est inutile. On observe des valeurs manquantes dans le dataset à travers les champs - et N/A, on souhaite remplacer ces valeurs textuelles par la véritable valeur NA permettant d’indiquer à R que la valeur est manquante. Construire une fonction appelée manage_na() qui prend en entrée : un vecteur x correspondra à une colonne d’un dataset. un vecteur string_to_na correspondant à la liste des chaînes de caractères qu’on souhaite transformer en NA. La fonction retournera le vecteur modifié. 💡 indice : voici ci-dessous la tête que doit avoir votre fonction : manage_na &lt;- function(x, string_to_na) { ... ... ... return(x_modif) } Construire une boucle qui parcourt toutes les colonnes du data frame AmongUs et qui remplace les champs avec des - et N/A par des valeurs manquantes NA. Utilisez la fonction manage_na() créée précédemment. Exercice 2 : Manipuler le texte et les dates À partir de la colonne Game.Completed.Date, construire une colonne appelée Date avec la date de la partie au format yyyy-mm-dd uniquement. Veiller à ce que le type de cette colonne soit Date. À partir de la colonne Game.Completed.Date, construire une colonne appelée Heure avec l’heure uniquement de la partie. Attention au format am et pm. À partir de la colonne Game Length, construire une colonne appelée Game.Length.sec correspondant à la durée de la partie en secondes. À partir de la colonne Time.to.complete.all.tasks, construire une colonne appelée Complete.all.tasks.sec correspondant à la durée en secondes pour compléter toutes les tâches. À partir de la colonne Region.Game.Code construire une colonne appelée Region correspondant au nom du continent uniquement. Exercice 3 : Type des variables Combien de lignes, colonnes sont présentes dans ce dataset (Utiliser la fonction adaptée) ? Afficher un résumé des données avec la fonction adaptée. Veiller à ce que les types de chaque colonne du dataset correspondent aux types ci-dessous. Sinon, convertir les variables dans leur type approprié. Variable Type souhaité Game.Completed.Date character Team factor Outcome factor Task.Completed numeric All.Tasks.Completed factor Murdered factor Imposter.Kills numeric Game.Length character Ejected factor Sabotages.Fixed numeric Time.to.complete.all.tasks character Region.Game.Code character Date Date Heure numeric Game.Length.sec numeric Complete.all.tasks.sec numeric Region factor 📢 Attention, lorsqu’on convertit un vecteur de type factor en type numeric, il est recommandé de passer d’abord par le type character (voir exemple ci-dessous). Ce ne sera peu être pas utile pour ce TP, mais c’est bien de le savoir ! Ce qu’il ne faut pas faire ⛔ x &lt;- factor(c(7,7,8,7,9,6,6)) levels(x) ## [1] &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; x &lt;- as.numeric(x) x ## [1] 2 2 3 2 4 1 1 Ce qu’il faut faire ✅ x &lt;- factor(c(7,7,8,7,9,6,6)) levels(x) ## [1] &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; x &lt;- as.numeric(as.character(x)) x ## [1] 7 7 8 7 9 6 6 Vérifier si cela a fonctionné en affichant le type de chaque variable du data frame. Exercice 4 : Analyses statistiques La plupart des questions de cet exercice demandent un peu de réflexion. 📢 Ne partez pas à l’abordage, les solutions peuvent se coder en plusieurs étapes (tris,filtres, agregations, etc.). Quelle est la durée moyenne d’une partie ? Combien y-a-t-il de régions serveurs différentes ?. Combien de tâche maximum un Crewmate peut-il réaliser ? Quel est le taux de parties remportées par les imposteurs ? Construire un graphique adapté permettant de visualiser la répartition du nombre de parties jouées selon laRegion. Construire un graphique adapté permettant de visualiser la répartition des joueurs qui termine ou pas leurs tâches selon s’ils se font tuer ou pas. Construire un graphique adapté permettant de visualiser la distribution du nombre de tâches complétées par les joueurs. Construire un graphique adapté permettant de visualiser pour chaque partie jouée, la durée de la partie et le temps pour compléter toutes les tâches. Construire un graphique adapté permettant de visualiser la distribution du temps des parties selon la Region. Construire un graphique adapté permettant de visualiser l’évolution du nombre de parties jouées selon l’heure de la journée. Construire un graphique adapté permettant de visualiser les variations du taux de succès des imposteurs selon les régions serveurs. Construire un graphique adapté permettant de visualiser les taux de succès des 5 meilleurs utilisateurs. 13.4 TP4 Difficulté 🏆🏆 Ce TP reprend les notions évoquées dans les chapitres 2 à 7. On utilise le fichier NBA.csv qui décrit les tirs effectués au cours de la saison 2014-2015 de NBA. Le fichier est issu du site Kaggle. Il a été adapté et modifié pour ce cours. Les données sont accessibles en cliquant ici. Voici la présentation du jeu de données : GAME_ID : ID du match LOCATION : Lieu du match (Home / Away) GAME_RESULT : Résultat du match (Won / Lost) PERIOD : Numéro de quart-temps et prolongations éventuelles SHOT_CLOCK : Durée de la possession de l’équipe au moment du tir DRIBBLES : Nombre de dribbles avant le tir TOUCH_TIME : Durée de la possession du joueur avant le tir SHOT_DIST : Distance de tir en foot (1 foot = 0,30 mètre) PTS_TYPE : Tentative à 2 ou 3 points (les lancers francs à 1 point ne sont pas répertoriés) SHOT_RESULT : Résultat du tir (made / missed) CLOSE_DEF_DIST : Distance entre le tireur et le défenseur le plus proche en foot (1 foot = 0,30 mètre) SHOOTER : Nom du tireur GAME_ID LOCATION GAME_RESULT PERIOD SHOT_CLOCK DRIBBLES TOUCH_TIME SHOT_DIST PTS_TYPE SHOT_RESULT CLOSE_DEF_DIST SHOOTER 21400899 A W 1 10.8 2 1.9 7.7 2 made 1.3 brian roberts 21400899 A W 1 3.4 0 0.8 28.2 3 missed 6.1 brian roberts 21400899 A W 1 NA 3 2.7 10.1 2 missed 0.9 brian roberts 21400899 A W 2 10.3 2 1.9 17.2 2 missed 3.4 brian roberts 21400899 A W 2 10.9 2 2.7 3.7 2 missed 1.1 brian roberts 21400899 A W 2 9.1 2 4.4 18.4 2 missed 2.6 brian roberts 21400899 A W 4 14.5 11 9.0 20.7 2 missed 6.1 brian roberts 21400899 A W 4 3.4 3 2.5 3.5 2 made 2.1 brian roberts 21400899 A W 4 12.4 0 0.8 24.6 3 missed 7.3 brian roberts 21400890 H W 2 17.4 0 1.1 22.4 3 missed 19.8 brian roberts 21400890 H W 2 16.0 8 7.5 24.5 3 missed 4.7 brian roberts 21400890 H W 4 12.1 14 11.9 14.6 2 made 1.8 brian roberts 21400890 H W 4 4.3 2 2.9 5.9 2 made 5.4 brian roberts 21400882 A W 4 4.4 0 0.8 26.4 3 missed 4.4 brian roberts 21400859 A L 1 6.8 0 0.5 22.8 3 missed 5.3 brian roberts 21400859 A L 2 6.4 3 2.7 24.7 3 made 5.6 brian roberts 21400859 A L 2 17.6 6 5.1 25.0 3 missed 5.4 brian roberts 21400859 A L 4 8.7 1 0.9 25.6 3 missed 5.1 brian roberts 21400859 A L 4 20.8 0 1.2 24.2 3 made 11.1 brian roberts 21400845 A W 1 17.5 2 2.2 25.4 3 missed 3.5 brian roberts Exercice 1 : Importer les données Importer le jeu de données NBA.csv avec la fonction read.csv(). Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ? Afficher le nom des colonnes. Afficher le type des colonnes avec la fonction adaptée. On souhaite analyser les variables PERIOD, PTS_TYPE, et SHOOTER en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor. Combien de niveaux (levels) sont présents dans ces variables ? Afficher un résumé des données avec la fonction adaptée. Exercice 2 : Statistiques descriptives Calculer l’écart-type de la variable présentant la distance de tir (SHOT_DIST). Calculer l’écart-type de la variable présentant la durée de la possession de l’équipe au moment du tir (SHOT_CLOCK). Calculer la répartition du nombre de tirs manqués et réussis (SHOT_RESULT). Calculer les quartiles de la variable présentant le nombre de dribbles avant un tir (DRIBBLES). Calculer les déciles de la variable présentant la distance entre le tireur et le défenseur le plus proche (CLOSE_DEF_DIST). Combien de matchs se sont déroulés lors de cette saison de basket ? Combien y-a-t-il de SHOOTER différents ? Exercice 3 : Modifier le jeu de données Créer une variable SHOT_DIST_METRE qui affiche la variable SHOT_DIST convertit en mètre (1 foot = 0,30 mètre). Créer une variable PTS_MARQUES qui prend la valeur 0, 2 ou 3 en fonction de l’issue du tir. Supprimer la variable GAME_RESULT car elle est inutile. Exercice 4 : Interroger les données Attention, certaines questions peuvent nécessiter plusieurs étapes. Penser à vérifier vos requêtes avec la fonction dim() ou View().Pour chaque question, affecter le résultat ddans un objet comme dans l’exemple ci-dessous. #Selectionnez les deux premières colonnes du data frame requete_0 &lt;- NBA[, c(1,2)] On souhaite extraire uniquement la colonne SHOOTER , SHOT_RESULT et PTS_TYPE dans cet ordre. On souhaite extraire uniquement les 50 premières lignes. On souhaite extraire toutes les colonnes sauf la première. On souhaite extraire uniquement les 100 tirs tentés avec les SHOT_DIST les plus loin. On souhaite extraire uniquement les 100 tirs réussis avec les SHOT_DIST les plus loin. On souhaite extraire uniquement les tirs réussis à 3 points de kobe bryant. On souhaite construire un data frame avec les 5 SHOOTER qui ont inscrit le plus de points. Bonus On souhaite construire un programme permettant de parcourir l’ensemble des colonnes du data frame : Si la colonne est numeric,on souhaite construire un boxplot. Si la colonne est factor, on souhaite construire un barplot. Sinon, on ne fait rien. Pensez à ajouter un titre sur les graphiques afin de savoir à quelle variable on a à faire. Dans une boucle,lorsqu’on souhaite affcher un graphique ou une sortie dans la console, il faut utiliser la fonction print(). 13.5 TP5 - Chercher l’erreur Difficulté 🏆🏆 Ce TP reprend les notions évoquées dans les chapitres 2 à 7. Dans ce TP, vous incarnez un data analyst travaillant dans le service statistique de la NBA. Un de vos collègues est parti en vacances vendredi dernier et a envoyer à votre manager quelques statistiques sur les tirs effectués au cours de la saison 2014-2015. Le problème c’est que le script est bourré de fautes ! Rien ne fonctionne, à tous les coups, votre collègue était pressé de partir en vacance. Votre manager fait donc appel à vous pour corriger les erreurs de ce script. Attention, votre manager aimerait également comprendre ce que vous programmez dans votre script alors n’oubliez pas de commenter chaque ligne de code pour qu’il la comprenne. Le fichier de données (NBA.csv) et le script de votre collègue (nba_stats.R) sont disponibles en cliquant ici. 🎯 Votre manager a déjà passé beaucoup de temps pour comprendre ce script et aimerait que votre correction garde la même philosophie que le script de votre collègue, cela signifie qu’il ne faut pas écrire d’autres commandes R et simplement faire en sorte que celles déjà présentes fonctionnent. 13.6 TP6 - Analyses statistiques Difficulté 🏆🏆 Ce TP reprend les notions évoquées dans les chapitres 2 à 5. On utilise le fichier students_results.csv qui décrit les notes d’étudiants sur différentes épreuves. Pour réaliser ce TP, télécharger le fichier en cliquant ici. Voici une description des données : ID_etudiant : Le matricule des étudiants Genre : Le genre des étudiants Groupe.TP : Le groupe de travaux pratiques Groupe.TD : Le groupe de travaux dirigés QUIZ# : Le score du quiz numéro # TP# : La note au TP numéro # ID_etudiant Genre Groupe.TP Groupe.TD QUIZ1 QUIZ2 TP1 TP2 TP4 42247 F 1 1 39774 25587 0.8095238 0.6470588 14.00 84675 F 1 1 27029 16083 0.9523810 0.6470588 14.50 93817 F 1 1 24839 20601 0.9523810 NA 13.00 22886 H 1 1 33835 22853 0.7619048 0.7794118 13.50 49060 H 1 1 31817 21322 0.8095238 0.8823529 16.00 66756 H 1 1 NA NA NA NA NA 48147 H 1 1 30572 18889 0.9523810 0.6470588 15.00 86478 H 1 1 26072 16057 0.8095238 NA 7.25 9082 H 1 1 32028 25880 0.8095238 0.6470588 13.00 2851 H 1 1 32945 25293 0.8095238 NA 11.00 94187 H 1 1 NA NA NA NA NA 2060 H 1 1 31588 17365 0.7619048 0.7794118 12.50 79464 H 1 1 34180 32996 0.8809524 NA 7.00 42086 H 1 1 36817 21302 0.9523810 1.0000000 19.00 4921 F 2 1 27838 20305 0.9523810 1.0000000 13.50 23653 H 2 1 33856 18854 0.9047619 0.9117647 16.50 26956 H 2 1 33375 18970 1.0000000 1.0000000 19.00 10702 H 2 1 34778 15677 1.0000000 1.0000000 13.50 22 H 2 1 36265 22377 1.0000000 1.0000000 17.50 3179 H 2 1 32809 23123 0.9047619 0.9117647 18.50 Exercice 1 : Importer les données Importer le jeu de données students_results.csv avec la fonction read.csv(). Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ? Afficher le nom des colonnes. Afficher le type des colonnes avec la fonction adaptée. Afficher un résumé des données avec la fonction adaptée. On souhaite analyser les variables Groupe.TP et Groupe.TD en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor. Exercice 2 : Statistiques descriptives Ajouter une colonne appelée TOTAL_QUIZ qui correspond à la somme des notes des quiz. Déterminer la moyenne du score total des quiz. Proposez un graphique adapté pour visualiser la distribution de tous les scores totaux des étudiants Déterminer les déciles des notes du TP4. Proposez un autre graphique pour visualiser la distribution des notes des étudiants au TP4. Déterminer le nombre d’étudiants par groupe de TP. Proposez un graphique adapté pour visualiser cette répartition par groupe. Déterminer le nombre d’étudiants par genre. Proposez un autre graphique pour visualiser cette répartition par genre. Exercice 3 : Qui sont les meilleurs ? Proposer un graphique adapté pour visualiser la distribution du score total aux quiz par genre. Calculer la moyenne du score total aux quiz par genre Proposer un graphique adapté pour visualiser la distribution du score total aux quiz par groupe de TP. Calculer la moyenne du score total aux quiz par groupe de TP. On souhaite visualiser avec un graphique adapté le score total aux quiz uniquement des 5 meilleurs étudiants. On souhaite conserver les lignes uniquement des 3 meilleur(e)s étudiant(e)s du groupe de TP 1. Exercice 4 : Allez plus loin Dans cet exercice, nous allons aller plus loin sur des notions qu’on peut retrouver en analyses statistiques comme des corrélations et des régressions linéaires. On va déterminer quelle variable est la plus corrélée avec la note du TP4 qui a été réalisé en condition d’examen. Puis nous modéliserons cette relation. Y-a-t-il une corrélation entre la note au TP4 et le score total aux quiz ? Pour cela, utiliser la fonction cor(). Voici un exemple d’utilisation avec le dataset iris ci-dessous: help(&quot;cor&quot;) cor(x = iris$Sepal.Length, y = iris$Sepal.Width) ## [1] -0.1175698 On peut aussi utiliser la fonction cor() où l’argument x est un data frame avec uniquement les variables quantitatives qu’on souhaite analyser. Cela permet d’obtenir ce qu’on appelle une matrice de corrélation. Voici ci-dessous un exemple d’utilisation avec le dataset iris. Construire la matrice de corrélation des scores aux quiz et des notes des TP. #On construit la matrice de corrélation sur le dataset iris en excluant la colonne 5 qui est qualitative cor(iris[ , -5]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Sepal.Length 1.0000000 -0.1175698 0.8717538 0.8179411 ## Sepal.Width -0.1175698 1.0000000 -0.4284401 -0.3661259 ## Petal.Length 0.8717538 -0.4284401 1.0000000 0.9628654 ## Petal.Width 0.8179411 -0.3661259 0.9628654 1.0000000 La fonction corrplot() du package corrplot du même nom permet de visualiser une matrice de corrélation. Ce graphique s’appelle aussi un corrélogramme. Construire un corrplot de la matrice de corrélation calculée précédemment. Consulter cette page pour plus d’information. En le personnalisant, on peut obtenir le corrélogramme ci-dessous : Quelle est la variable la plus corrélée avec la note au TP4 ? Pour illustrer cette corrélation, construire un nuage de points des notes du TP4 en fonction de la variable la plus corrélée comme ci-dessous : On observe une relation linéaire entre ces deux variables. On va calculer la droite qui permet de modéliser cette relation On parle alors de droite de régression. Cette méthode permet d’établir une relation mathématique entre une variable explicative \\(x\\) et une variable à expliquer \\(y\\) telles que \\(y = ax + b\\) où : \\(a\\) est le coefficient directeur aussi appelé la pente. \\(b\\) est la constante où la valeur de l’ordonnée \\(y\\) lorsque l’abscisse \\(x\\) vaut 0. Voici un exemple : Calculer ces deux indicateurs sachant que : \\(a = \\frac{s_{xy}}{s^2_x}\\) où \\(s_{xy}\\) est la covariance entre \\(x\\) et \\(y\\) et \\(s^2_x\\) est la variance de la variable explicative. On peut la calculer avec la fonction cov(). \\(b=\\bar{y}-a\\bar{x}\\) où \\(\\bar{x}\\) et \\(\\bar{y}\\) correspondent respectivement à la moyenne de la variable explicative et la variable à expliquer. 📢 Il est recommandé de calculer ces indicateurs sur un tableau filtré avec uniquement les lignes ne présentant pas de valeurs manquantes sur la variable explicative et la note au TP4. ## [1] &quot;Le coefficient directeur a vaut 14.2&quot; ## [1] &quot;La constante b vaut 2.79&quot; Après avoir calculé \\(a\\) et \\(b\\), Tracer la droite de régression sur le nuage de points avec la fonction abline(). help(&quot;abline&quot;) En réalité, pour éviter tous ces calculs, on peut directement utiliser la fonction lm() qui gère déjà les valeurs manquantes. help(&quot;lm&quot;) modele &lt;- lm(TP4 ~ TP2, data = df) modele$coefficients ## (Intercept) TP2 ## 2.789817 14.203363 plot(x = df$TP2, y = df$TP4, xlim = c(0,1), ylim = c(0,20), xlab = &quot;TP2&quot;, ylab = &quot;TP4&quot;, main = &quot;Note du TP4 en fonction de la note du TP2&quot;) abline(modele) 13.7 TP7 - Analyse de film Difficulté 🏆🏆 Streaming Ce TP reprend les notions évoquées dans les chapitres 2 à 6. On utilise le fichier tv_shows.csv qui décrit les notes d’évaluation des films et séries disponibles sur diverses plateformes de diffusion en continu. Le fichier est issu du site Kaggle. Il a été adapté pour ce TP. Pour réaliser ce TP, télécharger le fichier en cliquant ici.Voici une description des données : Title : titre de la série ou du film Year : Année de sortie ou première diffusion Age : Type de public conseillé IMDb : Notes des utilisateurs enregistrés sur le site L’Internet Movie Database Rotten.Tomatoes : Notes basées sur les opinions de centaines de critiques de cinéma et de télévision du site du même nom Netflix : si le film ou la série est disponible sur cette plateforme Hulu : si le film ou la série est disponible sur cette plateforme Prime.Video : si le film ou la série est disponible sur cette plateforme Disney. : si le film ou la série est disponible sur cette plateforme Exercice 1 : Importer les données Importer le jeu de données tv_shows.csv avec la fonction read.csv. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez la ou les fonctions adaptées) ? Afficher le nom des colonnes. Afficher un résumé des données avec la fonction adaptée. On souhaite analyser les variables Yearen tant que variable qualitative. Modifier le type de cette variable pour la transformer en type factor. Afficher le type de chaque variable avec la fonction adaptée. Construire une colonne appelée Total_plateforme avec le nombre de plateforme où est disponible le film ou la série. Exercice 2 : Statistiques descriptives 👨🏻‍🏫 Ne pas oublier de mettre des titres sur vos graphiques ! Déterminer la moyenne des notes IMDb. Déterminer le nombre de modalités de type de public conseillé (variable Age). Déterminer les centiles des notes Rotten.Tomatoes. Déterminer l’écart-type des notes IMDb puis Rotten.Tomatoes. Représenter graphiquement la distribution des notes utilisateurs (variable IMDb). Déterminer un tri à plat pour compter les effectifs des modalités de type de public conseillé (variable Age). Représenter graphiquement ce tri à plat de la modalité la plus représentée à la moins représentée. Calculer la répartition en pourcentage du nombre de films ou séries présents sur la plateforme Netflix. Représenter graphiquement cette répartition dans un diagramme circulaire. Représenter graphiquement la distribution des notes utilisateurs (variable IMDb) selon le type de public conseillé (variable Age). Exercice 3 : Tris, filtres et agrégations 💡 On peut vérifier si la question est correcte en affichant le résultat dans une vue. Construire un objet requete_a avec uniquement les films grands public (variable Age : all). Puis les trier de la note utilisateur (variable IMDb) de la plus élevée à la plus basse. Construire un objet requete_b avec uniquement les films ayant une note utilisateur (variable IMDb) supérieure ou égale à 9. Puis les trier par année de sortie de la plus ancienne à la plus récente Construire un objet requete_c avec uniquement les films ayant une note utilisateur (variable IMDb) et une note critique (variable Rotten.Tomatoes) qui soient renseignées. Puis les trier par ordre alphabétique (de A à Z) Construire un objet requete_d avec la moyenne des notes utilisateurs (variable IMDb) selon le type de public conseillé (variable Age). Puis les trier de la note utilisateur (variable IMDb) de la plus élevée à la plus basse. Bonus Représenter grahiquement le lien entre les notes utilisateurs et les notes des critiques. Calculer le coefficient de corrélation entre les notes utilisateurs et les notes des critiques. Attention, les NA pourraient vous poser des problèmes mais avec use = \"complete.obs\" dans la fonction cela devrait fonctionner. "],
["all-dataset.html", "Chapitre 14 Jeux de données utilisés 14.1 Iris 🌺 14.2 Histoire de vie (hdv2003) 🗨 14.3 NYC Flights 2013 ✈ 14.4 Google 📱 14.5 Pokemon 🐾 14.6 Star Wars 🎬 14.7 AmongUs 🔦 14.8 NBA 🏀 14.9 Students 🎓 14.10 TV Shows 📺", " Chapitre 14 Jeux de données utilisés Ce chapitre présente les différents jeux de données utilisés dans ce livre. 14.1 Iris 🌺 Le jeu de données présente les caractéristiques de 3 espèces de fleurs. Il est intégré au package datasets déjà chargé à chaque ouverture de session dans RStudio. Voici la présentation du jeu de données : Sepal.Length : longueur du sépale Sepal.Width : largeur du sépale Petal.Length : longueur du pétale Petal.Width : largeur du pétale Species : l’espèce de la fleur dim(iris) ## [1] 150 5 Voici un extrait du dataset : Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa 14.2 Histoire de vie (hdv2003) 🗨 Le jeu de données est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) : library(questionr) Nous devons ensuite indiquer à R que nous souhaitons accéder au jeu de données à l’aide de la commande data : data(hdv2003) Cette commande ne renvoie aucun résultat particulier (sauf en cas d’erreur), mais vous devriez voir apparaître dans l’onglet Environment de RStudio un nouvel objet nommé hdv2003 : On utilise la fonction dim pour connaître la taille du dataset dim(hdv2003) ## [1] 2000 20 Voici un extrait du dataset : id age sexe nivetud poids occup qualif freres.soeurs clso relig trav.imp trav.satisf hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv 1 28 Femme Enseignement superieur y compris technique superieur 2634.3982 Exerce une profession Employe 8 Oui Ni croyance ni appartenance Peu important Insatisfaction Non Non Non Oui Non Non Non 0.0 2 23 Femme NA 9738.3958 Etudiant, eleve NA 2 Oui Ni croyance ni appartenance NA NA Non Non Non Non Non Oui Oui 1.0 3 59 Homme Derniere annee d’etudes primaires 3994.1025 Exerce une profession Technicien 2 Non Ni croyance ni appartenance Aussi important que le reste Equilibre Non Non Non Non Non Non Oui 0.0 4 34 Homme Enseignement superieur y compris technique superieur 5731.6615 Exerce une profession Technicien 1 Non Appartenance sans pratique Moins important que le reste Satisfaction Non Non Non Oui Oui Oui Oui 2.0 5 71 Femme Derniere annee d’etudes primaires 4329.0940 Retraite Employe 0 Oui Pratiquant regulier NA NA Non Non Non Non Non Non Non 3.0 6 35 Femme Enseignement technique ou professionnel court 8674.6994 Exerce une profession Employe 5 Non Ni croyance ni appartenance Le plus important Equilibre Non Non Non Non Non Oui Oui 2.0 7 60 Femme Derniere annee d’etudes primaires 6165.8035 Au foyer Ouvrier qualifie 1 Oui Appartenance sans pratique NA NA Non Non Oui Oui Non Non Non 2.9 8 47 Homme Enseignement technique ou professionnel court 12891.6408 Exerce une profession Ouvrier qualifie 5 Non Ni croyance ni appartenance Peu important Insatisfaction Non Non Oui Oui Oui Non Non 1.0 9 20 Femme NA 7808.8721 Etudiant, eleve NA 4 Oui Appartenance sans pratique NA NA Non Non Non Non Non Oui Non 2.0 10 28 Homme Enseignement technique ou professionnel long 2277.1605 Exerce une profession Autre 2 Non Pratiquant occasionnel Moins important que le reste Satisfaction Non Non Non Non Non Oui Oui 2.0 11 65 Femme Enseignement superieur y compris technique superieur 704.3227 Retraite Employe 3 Oui Appartenance sans pratique NA NA Non Non Non Oui Oui Oui Non 1.0 12 47 Homme 2eme cycle 6697.8682 Exerce une profession Ouvrier qualifie 4 Oui Appartenance sans pratique Moins important que le reste Satisfaction Non Non Non Non Oui Non Oui 0.0 13 63 Femme Derniere annee d’etudes primaires 7118.4659 Retraite Employe 1 Oui Appartenance sans pratique NA NA Non Non Non Oui Non Non Non 4.0 14 67 Femme Enseignement technique ou professionnel court 586.7714 Exerce une profession NA 5 Oui Pratiquant occasionnel Moins important que le reste Satisfaction Non Non Non Oui Oui Non Non 1.0 15 76 Femme A arrete ses etudes, avant la derniere annee d’etudes primaires 11042.0774 Retraite NA 2 Oui Appartenance sans pratique NA NA Non Non Non Oui Non Oui Non 3.0 16 49 Femme Enseignement technique ou professionnel court 9958.2287 Exerce une profession Employe 3 Non Pratiquant occasionnel Moins important que le reste Equilibre Non Non Non Non Non Oui Non 0.0 17 62 Homme Enseignement superieur y compris technique superieur 4836.1393 Retraite Cadre 4 Non Pratiquant regulier NA NA Non Non Non Oui Oui Oui Oui 1.0 18 20 Femme NA 1551.4846 Etudiant, eleve NA 0 Non Appartenance sans pratique NA NA Non Non Non Oui Oui Oui Oui 3.0 19 70 Homme Derniere annee d’etudes primaires 3141.1572 Retraite Ouvrier specialise 2 Non Appartenance sans pratique NA NA Non Non Non Non Non Non Non 1.0 20 39 Femme Enseignement technique ou professionnel court 27195.8378 Exerce une profession Ouvrier qualifie 5 Non Appartenance sans pratique Moins important que le reste Satisfaction Non Non Non Non Non Oui Oui 2.7 14.3 NYC Flights 2013 ✈ Le package nycflights13 propose plusieurs data.frame. Ceux-ci correspondent aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. library(nycflights13) ls(&quot;package:nycflights13&quot;) ## [1] &quot;airlines&quot; &quot;airports&quot; &quot;flights&quot; &quot;planes&quot; &quot;weather&quot; 14.3.1 Flights Cette table présente les informations qui caractérisent un vol, Voici la présentation du jeu de données : year, month, day : date du vol. dep_time, arr_time : Heures de départ et d’arrivée réelles (format HHMM ou HMM). sched_dep_time,sched_arr_time : Heures de départ et d’arrivée prévues (format HHMM ou HMM). dep_delay, arr_delay : Retards de départ et d’arrivée, en minutes. Les temps négatifs représentent des départs / arrivées précoces. carrier : Abréviation à deux lettres des compagnies aériennes. flights : Numéro de vol tailnum : Immatriculation de l’avion origine, dest : Aéroport de départ et destination. air_time : Durée du vol en minutes. distance : Distance entre les aéroports, en miles. hour , minute : Heure de départ prévue divisée en heures et minutes. time_hour : Date et heure prévues du vol dim(flights) ## [1] 336776 19 Voici un extrait du dataset : year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest air_time distance hour minute time_hour 2013 1 1 517 515 2 830 819 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2013-01-01T10:00:00Z 2013 1 1 533 529 4 850 830 20 UA 1714 N24211 LGA IAH 227 1416 5 29 2013-01-01T10:00:00Z 2013 1 1 542 540 2 923 850 33 AA 1141 N619AA JFK MIA 160 1089 5 40 2013-01-01T10:00:00Z 2013 1 1 544 545 -1 1004 1022 -18 B6 725 N804JB JFK BQN 183 1576 5 45 2013-01-01T10:00:00Z 2013 1 1 554 600 -6 812 837 -25 DL 461 N668DN LGA ATL 116 762 6 0 2013-01-01T11:00:00Z 2013 1 1 554 558 -4 740 728 12 UA 1696 N39463 EWR ORD 150 719 5 58 2013-01-01T10:00:00Z 2013 1 1 555 600 -5 913 854 19 B6 507 N516JB EWR FLL 158 1065 6 0 2013-01-01T11:00:00Z 2013 1 1 557 600 -3 709 723 -14 EV 5708 N829AS LGA IAD 53 229 6 0 2013-01-01T11:00:00Z 2013 1 1 557 600 -3 838 846 -8 B6 79 N593JB JFK MCO 140 944 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 753 745 8 AA 301 N3ALAA LGA ORD 138 733 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 849 851 -2 B6 49 N793JB JFK PBI 149 1028 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 853 856 -3 B6 71 N657JB JFK TPA 158 1005 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 924 917 7 UA 194 N29129 JFK LAX 345 2475 6 0 2013-01-01T11:00:00Z 2013 1 1 558 600 -2 923 937 -14 UA 1124 N53441 EWR SFO 361 2565 6 0 2013-01-01T11:00:00Z 2013 1 1 559 600 -1 941 910 31 AA 707 N3DUAA LGA DFW 257 1389 6 0 2013-01-01T11:00:00Z 2013 1 1 559 559 0 702 706 -4 B6 1806 N708JB JFK BOS 44 187 5 59 2013-01-01T10:00:00Z 2013 1 1 559 600 -1 854 902 -8 UA 1187 N76515 EWR LAS 337 2227 6 0 2013-01-01T11:00:00Z 2013 1 1 600 600 0 851 858 -7 B6 371 N595JB LGA FLL 152 1076 6 0 2013-01-01T11:00:00Z 2013 1 1 600 600 0 837 825 12 MQ 4650 N542MQ LGA ATL 134 762 6 0 2013-01-01T11:00:00Z 2013 1 1 601 600 1 844 850 -6 B6 343 N644JB EWR PBI 147 1023 6 0 2013-01-01T11:00:00Z 14.3.2 Airlines La table airlines contient des données sur les compagnies aériennes dim(airlines) ## [1] 16 2 Voici un extrait du dataset : carrier name 9E Endeavor Air Inc. AA American Airlines Inc. AS Alaska Airlines Inc. B6 JetBlue Airways DL Delta Air Lines Inc. EV ExpressJet Airlines Inc. F9 Frontier Airlines Inc. FL AirTran Airways Corporation HA Hawaiian Airlines Inc. MQ Envoy Air OO SkyWest Airlines Inc. UA United Air Lines Inc. US US Airways Inc. VX Virgin America WN Southwest Airlines Co. YV Mesa Airlines Inc. 14.3.3 Airports La table airports contient des informations sur les aéroports dim(airports) ## [1] 1458 8 Voici un extrait du dataset : faa name lat lon alt tz dst tzone 04G Lansdowne Airport 41.13047 -80.61958 1044 -5 A America/New_York 06A Moton Field Municipal Airport 32.46057 -85.68003 264 -6 A America/Chicago 06C Schaumburg Regional 41.98934 -88.10124 801 -6 A America/Chicago 06N Randall Airport 41.43191 -74.39156 523 -5 A America/New_York 09J Jekyll Island Airport 31.07447 -81.42778 11 -5 A America/New_York 0A9 Elizabethton Municipal Airport 36.37122 -82.17342 1593 -5 A America/New_York 0G6 Williams County Airport 41.46731 -84.50678 730 -5 A America/New_York 0G7 Finger Lakes Regional Airport 42.88356 -76.78123 492 -5 A America/New_York 0P2 Shoestring Aviation Airfield 39.79482 -76.64719 1000 -5 U America/New_York 0S9 Jefferson County Intl 48.05381 -122.81064 108 -8 A America/Los_Angeles 0W3 Harford County Airport 39.56684 -76.20240 409 -5 A America/New_York 10C Galt Field Airport 42.40289 -88.37511 875 -6 U America/Chicago 17G Port Bucyrus-Crawford County Airport 40.78156 -82.97481 1003 -5 A America/New_York 19A Jackson County Airport 34.17586 -83.56160 951 -5 U America/New_York 1A3 Martin Campbell Field Airport 35.01581 -84.34683 1789 -5 A America/New_York 1B9 Mansfield Municipal 42.00013 -71.19677 122 -5 A America/New_York 1C9 Frazier Lake Airpark 54.01333 -124.76833 152 -8 A America/Vancouver 1CS Clow International Airport 41.69597 -88.12923 670 -6 U America/Chicago 1G3 Kent State Airport 41.15139 -81.41511 1134 -5 A America/New_York 1G4 Grand Canyon West Airport 35.89990 -113.81567 4813 -7 A America/Phoenix 14.3.4 Weather La table weather contient des informations sur les conditions météorologiques dim(weather) ## [1] 26115 15 Voici un extrait du dataset : origin year month day hour temp dewp humid wind_dir wind_speed wind_gust precip pressure visib time_hour EWR 2013 1 1 1 39.02 26.06 59.37 270 10.35702 NA 0 1012.0 10 2013-01-01 01:00:00 EWR 2013 1 1 2 39.02 26.96 61.63 250 8.05546 NA 0 1012.3 10 2013-01-01 02:00:00 EWR 2013 1 1 3 39.02 28.04 64.43 240 11.50780 NA 0 1012.5 10 2013-01-01 03:00:00 EWR 2013 1 1 4 39.92 28.04 62.21 250 12.65858 NA 0 1012.2 10 2013-01-01 04:00:00 EWR 2013 1 1 5 39.02 28.04 64.43 260 12.65858 NA 0 1011.9 10 2013-01-01 05:00:00 EWR 2013 1 1 6 37.94 28.04 67.21 240 11.50780 NA 0 1012.4 10 2013-01-01 06:00:00 EWR 2013 1 1 7 39.02 28.04 64.43 240 14.96014 NA 0 1012.2 10 2013-01-01 07:00:00 EWR 2013 1 1 8 39.92 28.04 62.21 250 10.35702 NA 0 1012.2 10 2013-01-01 08:00:00 EWR 2013 1 1 9 39.92 28.04 62.21 260 14.96014 NA 0 1012.7 10 2013-01-01 09:00:00 EWR 2013 1 1 10 41.00 28.04 59.65 260 13.80936 NA 0 1012.4 10 2013-01-01 10:00:00 EWR 2013 1 1 11 41.00 26.96 57.06 260 14.96014 NA 0 1011.4 10 2013-01-01 11:00:00 EWR 2013 1 1 13 39.20 28.40 69.67 330 16.11092 NA 0 NA 10 2013-01-01 13:00:00 EWR 2013 1 1 14 39.02 24.08 54.68 280 13.80936 NA 0 1010.8 10 2013-01-01 14:00:00 EWR 2013 1 1 15 37.94 24.08 57.04 290 9.20624 NA 0 1011.9 10 2013-01-01 15:00:00 EWR 2013 1 1 16 37.04 19.94 49.62 300 13.80936 20.71404 0 1012.1 10 2013-01-01 16:00:00 EWR 2013 1 1 17 35.96 19.04 49.83 330 11.50780 NA 0 1013.2 10 2013-01-01 17:00:00 EWR 2013 1 1 18 33.98 15.08 45.43 310 12.65858 25.31716 0 1014.1 10 2013-01-01 18:00:00 EWR 2013 1 1 19 33.08 12.92 42.84 320 10.35702 NA 0 1014.4 10 2013-01-01 19:00:00 EWR 2013 1 1 20 32.00 15.08 49.19 310 14.96014 NA 0 1015.2 10 2013-01-01 20:00:00 EWR 2013 1 1 21 30.02 12.92 48.48 320 18.41248 26.46794 0 1016.0 10 2013-01-01 21:00:00 14.3.5 Planes La table planes contient des informations sur les appareil dim(planes) ## [1] 3322 9 Voici un extrait du dataset : tailnum year type manufacturer model engines seats speed engine N10156 2004 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N102UW 1998 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N103US 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N104UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N10575 2002 Fixed wing multi engine EMBRAER EMB-145LR 2 55 NA Turbo-fan N105UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N107US 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N108UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N109UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N110UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 182 NA Turbo-fan N11106 2002 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11107 2002 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11109 2002 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11113 2002 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11119 2002 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11121 2003 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11127 2003 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11137 2003 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11140 2003 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan N11150 2003 Fixed wing multi engine EMBRAER EMB-145XR 2 55 NA Turbo-fan 14.4 Google 📱 Le dataset google.csv décrit des applications du store google. Le fichier est issu du site Kaggle. Il a été adapté dans ce livre. Voici la présentation du jeu de données : App : Nom de l’application Category : Catégorie de l’application Rating : Note moyenne des utilisateurs Reviews : Nombre d’avis d’utilisateurs Installs : Nombre d’installation Type : Application gratuite / payante Price : Prix de l’application Content.Rating : Public concerné Last.Updated : Date de la dernière version Size_recode : Taille de l’application (en Mo) google &lt;- read.csv(file = &quot;./dataset/google.csv&quot;, sep = &#39;\\t&#39;) dim(google) ## [1] 8196 10 Voici un extrait du dataset : App Category Rating Reviews Installs Type Price Content.Rating Last.Updated Size_recode Photo Editor &amp; Candy Camera &amp; Grid &amp; ScrapBook ART_AND_DESIGN 4.1 159 1e+04 Free 0 Everyone 2018-01-07T00:00:00Z 19.0 Coloring book moana ART_AND_DESIGN 3.9 967 5e+05 Free 0 Everyone 2018-01-15T00:00:00Z 14.0 U Launcher Lite – FREE Live Cool Themes, Hide Apps ART_AND_DESIGN 4.7 87510 5e+06 Free 0 Everyone 2018-08-01T00:00:00Z 8.7 Sketch - Draw &amp; Paint ART_AND_DESIGN 4.5 215644 5e+07 Free 0 Teen 2018-06-08T00:00:00Z 25.0 Pixel Draw - Number Art Coloring Book ART_AND_DESIGN 4.3 967 1e+05 Free 0 Everyone 2018-06-20T00:00:00Z 2.8 Paper flowers instructions ART_AND_DESIGN 4.4 167 5e+04 Free 0 Everyone 2017-03-26T00:00:00Z 5.6 Smoke Effect Photo Maker - Smoke Editor ART_AND_DESIGN 3.8 178 5e+04 Free 0 Everyone 2018-04-26T00:00:00Z 19.0 Infinite Painter ART_AND_DESIGN 4.1 36815 1e+06 Free 0 Everyone 2018-06-14T00:00:00Z 29.0 Garden Coloring Book ART_AND_DESIGN 4.4 13791 1e+06 Free 0 Everyone 2017-09-20T00:00:00Z 33.0 Kids Paint Free - Drawing Fun ART_AND_DESIGN 4.7 121 1e+04 Free 0 Everyone 2018-07-03T00:00:00Z 3.1 Text on Photo - Fonteee ART_AND_DESIGN 4.4 13880 1e+06 Free 0 Everyone 2017-10-27T00:00:00Z 28.0 Name Art Photo Editor - Focus n Filters ART_AND_DESIGN 4.4 8788 1e+06 Free 0 Everyone 2018-07-31T00:00:00Z 12.0 Tattoo Name On My Photo Editor ART_AND_DESIGN 4.2 44829 1e+07 Free 0 Teen 2018-04-02T00:00:00Z 20.0 Mandala Coloring Book ART_AND_DESIGN 4.6 4326 1e+05 Free 0 Everyone 2018-06-26T00:00:00Z 21.0 3D Color Pixel by Number - Sandbox Art Coloring ART_AND_DESIGN 4.4 1518 1e+05 Free 0 Everyone 2018-08-03T00:00:00Z 37.0 Learn To Draw Kawaii Characters ART_AND_DESIGN 3.2 55 5e+03 Free 0 Everyone 2018-06-06T00:00:00Z 2.7 Photo Designer - Write your name with shapes ART_AND_DESIGN 4.7 3632 5e+05 Free 0 Everyone 2018-07-31T00:00:00Z 5.5 350 Diy Room Decor Ideas ART_AND_DESIGN 4.5 27 1e+04 Free 0 Everyone 2017-11-07T00:00:00Z 17.0 FlipaClip - Cartoon animation ART_AND_DESIGN 4.3 194216 5e+06 Free 0 Everyone 2018-08-03T00:00:00Z 39.0 ibis Paint X ART_AND_DESIGN 4.6 224399 1e+07 Free 0 Everyone 2018-07-30T00:00:00Z 31.0 14.5 Pokemon 🐾 Le dataset pokemon.xlsx décrit les statistiques des pokemon des deux premières générations. Le fichier est issu du site Kaggle. Il a été adapté dans ce livre Voici la présentation du jeu de données : pokedex_number : numéro du pokemon nom : nom du pokemon generation : le numéro de génération dont est issu le pokemon is_legendary : Oui / Non si le pokemon est légendaire type : le type du pokemon weight_kg : le poids du pokemon en kg height_m : la taille du pokemon en mètre attack : la puissance d’attaque du pokemon defense : la puissance de défense du pokemon speed : la vitesse du pokemon library(readxl) pokemon &lt;- read_excel(path = &quot;./dataset/pokemon.xlsx&quot;, sheet = &quot;pokemon&quot;) dim(pokemon) ## [1] 251 10 pokedex_number nom generation is_legendary type weight_kg height_m attack defense speed 1 Bulbizarre 1 Non grass 6.9 0.7 49 49 45 2 Herbizarre 1 Non grass 13.0 1.0 62 63 60 3 Florizarre 1 Non grass 100.0 2.0 100 123 80 4 Salameche 1 Non fire 8.5 0.6 52 43 65 5 Reptincel 1 Non fire 19.0 1.1 64 58 80 6 Dracaufeu 1 Non fire 90.5 1.7 104 78 100 7 Carapuce 1 Non water 9.0 0.5 48 65 43 8 Carabaffe 1 Non water 22.5 1.0 63 80 58 9 Tortank 1 Non water 85.5 1.6 103 120 78 10 Chenipan 1 Non bug 2.9 0.3 30 35 45 11 Chrysacier 1 Non bug 9.9 0.7 20 55 30 12 Papilusion 1 Non bug 32.0 1.1 45 50 70 13 Aspicot 1 Non bug 3.2 0.3 35 30 50 14 Coconfort 1 Non bug 10.0 0.6 25 50 35 15 Dardargnan 1 Non bug 29.5 1.0 150 40 145 16 Roucool 1 Non normal 1.8 0.3 45 40 56 17 Roucoups 1 Non normal 30.0 1.1 60 55 71 18 Roucarnage 1 Non normal 39.5 1.5 80 80 121 19 Rattata 1 Non normal NA NA 56 35 72 20 Rattatac 1 Non normal NA NA 71 70 77 14.6 Star Wars 🎬 Le dataset starwars.csv décrit les caractéristiques des personnages principaux de la saga. starWars &lt;- read.csv(&quot;./dataset/starwars.csv&quot;, sep = &quot;\\t&quot;) dim(starWars) ## [1] 87 10 Voici un extrait du dataset : name height mass hair_color skin_color eye_color birth_year gender homeworld species Luke Skywalker 172 77 blond fair blue 19.0 male Tatooine Human C-3PO 167 75 NA gold yellow 112.0 NA Tatooine Droid R2-D2 96 32 NA white, blue red 33.0 NA Naboo Droid Darth Vader 202 136 none white yellow 41.9 male Tatooine Human Leia Organa 150 49 brown light brown 19.0 female Alderaan Human Owen Lars 178 120 brown, grey light blue 52.0 male Tatooine Human Beru Whitesun lars 165 75 brown light blue 47.0 female Tatooine Human R5-D4 97 32 NA white, red red NA NA Tatooine Droid Biggs Darklighter 183 84 black light brown 24.0 male Tatooine Human Obi-Wan Kenobi 182 77 auburn, white fair blue-gray 57.0 male Stewjon Human Anakin Skywalker 188 84 blond fair blue 41.9 male Tatooine Human Wilhuff Tarkin 180 NA auburn, grey fair blue 64.0 male Eriadu Human Chewbacca 228 112 brown unknown blue 200.0 male Kashyyyk Wookiee Han Solo 180 80 brown fair brown 29.0 male Corellia Human Greedo 173 74 NA green black 44.0 male Rodia Rodian Jabba Desilijic Tiure 175 1358 NA green-tan, brown orange 600.0 hermaphrodite Nal Hutta Hutt Wedge Antilles 170 77 brown fair hazel 21.0 male Corellia Human Jek Tono Porkins 180 110 brown fair blue NA male Bestine IV Human Yoda 66 17 white green brown 896.0 male NA Yoda’s species Palpatine 170 75 grey pale yellow 82.0 male Naboo Human 14.7 AmongUs 🔦 On utilise le fichier compressé AmongUs.7z où l’ensemble des fichiers décrivent les statistiques des parties jouées sur le jeu Among Us. Il y a un fichier par joueur nommé UserX.csv. Les données sont issues du site Kaggle. Vous pouvez les télécharger facilement en cliquant ici. Les fichiers csv ont tous la même structure avec : Game.Completed.Date : Date de la partie Team : l’équipe attribuée Outcome : résultat de la partie Task.Completed : le nombre de tâches effectuées All.Tasks.Completed : si toutes les tâches ont été effectuées Murdered : si le joueur a été tué Imposter.Kills : le nombre de joueurs tués par l’imposteur Game.Length : durée de la partie Ejected : si le joueur a été éliminé par les autres au cours de la partie Sabotages.Fixed : nombre de sabotages réparés Time.to.complete.all.tasks : temps pour compléter les toutes les tâches Rank.Change : Non renseigné Region.Game.Code : la région du serveur de jeu AmongUs &lt;-read.csv(&quot;./dataset/AmongUs.csv&quot;) dim(AmongUs) ## [1] 100 13 Voici un extrait du dataset : Game.Completed.Date Team Outcome Task.Completed All.Tasks.Completed Murdered Imposter.Kills Game.Length Ejected Sabotages.Fixed Time.to.complete.all.tasks Rank.Change Region.Game.Code 12/13/2020 at 1:26:56 am EST Crewmate Win 3 No Yes 07m 04s No 2 ++ NA / WYMSBF 12/13/2020 at 1:17:42 am EST Crewmate Loss 7 Yes No 16m 21s No 1 09m 48s – NA / WYMSBF 12/13/2020 at 12:57:47 am EST Crewmate Win 3 No No 11m 33s No 0 ++ NA / WYMSBF 12/13/2020 at 12:41:55 am EST Imposter Win 2 08m 05s No N/A +++ Europe / QIRTNF 12/13/2020 at 12:30:37 am EST Crewmate Loss 4 No No 05m 10s No 0 — Europe / QIRTNF 12/13/2020 at 12:24:20 am EST Crewmate Loss 7 Yes Yes 16m 22s No 0 12m 16s – Europe / QIRTNF 12/13/2020 at 12:00:39 am EST Crewmate Loss 8 Yes Yes 21m 41s No 1 18m 38s – Europe / MTKPVF 12/11/2020 at 4:15:08 pm EST Crewmate Win 8 Yes No 18m 43s Yes 0 07m 48s ++ Europe / BFRJCF 12/11/2020 at 3:49:33 pm EST Crewmate Win 7 Yes Yes 13m 15s No 0 13m 15s ++ Europe / BFRJCF 12/11/2020 at 3:30:36 pm EST Crewmate Loss 7 Yes Yes 12m 43s No 0 12m 43s – Europe / BFRJCF 12/11/2020 at 3:10:58 pm EST Crewmate Win 4 No Yes 11m 00s No 0 ++ Europe / BFRJCF 12/11/2020 at 2:53:28 pm EST Crewmate Win 7 Yes No 17m 43s No 0 11m 59s ++ Europe / BFRJCF 12/11/2020 at 2:20:38 pm EST Crewmate Loss 6 No Yes 13m 46s No 0 — Europe / ONSJWQ 12/11/2020 at 2:04:26 pm EST Imposter Loss 3 15m 52s Yes N/A Europe / ONSJWQ 12/11/2020 at 1:46:30 pm EST Crewmate Win 7 Yes Yes 18m 54s No 1 11m 09s ++ Europe / ONSJWQ 12/11/2020 at 2:09:32 am EST Crewmate Loss 7 Yes Yes 08m 00s No 0 01m 41s – NA / EYNONF 12/11/2020 at 2:00:26 am EST Crewmate Win 7 Yes Yes 18m 06s No 0 09m 34s ++ NA / EYNONF 12/11/2020 at 1:26:11 am EST Crewmate Win 7 Yes Yes 12m 58s No 1 09m 03s ++ NA / EYNONF 12/11/2020 at 1:03:05 am EST Crewmate Win 7 Yes Yes 14m 57s No 0 14m 50s ++ NA / EYNONF 12/11/2020 at 12:45:34 am EST Crewmate Loss 7 Yes Yes 11m 03s No 0 10m 34s – NA / EYNONF 14.8 NBA 🏀 Ce jeu de donnéesNBA.csv décrit les tirs effectués au cours de la saison 2014-2015 de NBA. Le fichier est issu du site Kaggle. Il a été adapté et modifié pour ce cours. Les données sont accessibles en cliquant ici. Voici la présentation du jeu de données : GAME_ID : ID du match LOCATION : Lieu du match (Home / Away) GAME_RESULT : Résultat du match (Won / Lost) PERIOD : Numéro de quart-temps et prolongations éventuelles SHOT_CLOCK : Durée de la possession de l’équipe au moment du tir DRIBBLES : Nombre de dribbles avant le tir TOUCH_TIME : Durée de la possession du joueur avant le tir SHOT_DIST : Distance de tir en foot (1 foot = 0,30 mètre) PTS_TYPE : Tentative à 2 ou 3 points (les lancers francs à 1 point ne sont pas répertoriés) SHOT_RESULT : Résultat du tir (made / missed) CLOSE_DEF_DIST : Distance entre le tireur et le défenseur le plus proche en foot (1 foot = 0,30 mètre) SHOOTER : Nom du tireur NBA &lt;- read.csv(&quot;./dataset/NBA.csv&quot;) dim(NBA) ## [1] 128069 12 GAME_ID LOCATION GAME_RESULT PERIOD SHOT_CLOCK DRIBBLES TOUCH_TIME SHOT_DIST PTS_TYPE SHOT_RESULT CLOSE_DEF_DIST SHOOTER 21400899 A W 1 10.8 2 1.9 7.7 2 made 1.3 brian roberts 21400899 A W 1 3.4 0 0.8 28.2 3 missed 6.1 brian roberts 21400899 A W 1 NA 3 2.7 10.1 2 missed 0.9 brian roberts 21400899 A W 2 10.3 2 1.9 17.2 2 missed 3.4 brian roberts 21400899 A W 2 10.9 2 2.7 3.7 2 missed 1.1 brian roberts 21400899 A W 2 9.1 2 4.4 18.4 2 missed 2.6 brian roberts 21400899 A W 4 14.5 11 9.0 20.7 2 missed 6.1 brian roberts 21400899 A W 4 3.4 3 2.5 3.5 2 made 2.1 brian roberts 21400899 A W 4 12.4 0 0.8 24.6 3 missed 7.3 brian roberts 21400890 H W 2 17.4 0 1.1 22.4 3 missed 19.8 brian roberts 21400890 H W 2 16.0 8 7.5 24.5 3 missed 4.7 brian roberts 21400890 H W 4 12.1 14 11.9 14.6 2 made 1.8 brian roberts 21400890 H W 4 4.3 2 2.9 5.9 2 made 5.4 brian roberts 21400882 A W 4 4.4 0 0.8 26.4 3 missed 4.4 brian roberts 21400859 A L 1 6.8 0 0.5 22.8 3 missed 5.3 brian roberts 21400859 A L 2 6.4 3 2.7 24.7 3 made 5.6 brian roberts 21400859 A L 2 17.6 6 5.1 25.0 3 missed 5.4 brian roberts 21400859 A L 4 8.7 1 0.9 25.6 3 missed 5.1 brian roberts 21400859 A L 4 20.8 0 1.2 24.2 3 made 11.1 brian roberts 21400845 A W 1 17.5 2 2.2 25.4 3 missed 3.5 brian roberts 14.9 Students 🎓 Le dataset students_results.csv décrit les notes d’étudiants sur différentes épreuves. Voici la présentation du jeu de données : ID_etudiant : Le matricule des étudiants Genre : Le genre des étudiants Groupe.TP : Le groupe de travaux pratiques Groupe.TD : Le groupe de travaux dirigés QUIZ# : Le score du quiz numéro # TP# : La note au TP numéro # df &lt;- read.csv(file = &quot;dataset/students_results.csv&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;) dim(df) ## [1] 54 9 ID_etudiant Genre Groupe.TP Groupe.TD QUIZ1 QUIZ2 TP1 TP2 TP4 42247 F 1 1 39774 25587 0.8095238 0.6470588 14.00 84675 F 1 1 27029 16083 0.9523810 0.6470588 14.50 93817 F 1 1 24839 20601 0.9523810 NA 13.00 22886 H 1 1 33835 22853 0.7619048 0.7794118 13.50 49060 H 1 1 31817 21322 0.8095238 0.8823529 16.00 66756 H 1 1 NA NA NA NA NA 48147 H 1 1 30572 18889 0.9523810 0.6470588 15.00 86478 H 1 1 26072 16057 0.8095238 NA 7.25 9082 H 1 1 32028 25880 0.8095238 0.6470588 13.00 2851 H 1 1 32945 25293 0.8095238 NA 11.00 94187 H 1 1 NA NA NA NA NA 2060 H 1 1 31588 17365 0.7619048 0.7794118 12.50 79464 H 1 1 34180 32996 0.8809524 NA 7.00 42086 H 1 1 36817 21302 0.9523810 1.0000000 19.00 4921 F 2 1 27838 20305 0.9523810 1.0000000 13.50 23653 H 2 1 33856 18854 0.9047619 0.9117647 16.50 26956 H 2 1 33375 18970 1.0000000 1.0000000 19.00 10702 H 2 1 34778 15677 1.0000000 1.0000000 13.50 22 H 2 1 36265 22377 1.0000000 1.0000000 17.50 3179 H 2 1 32809 23123 0.9047619 0.9117647 18.50 14.10 TV Shows 📺 Le dataset tv_shows.csv qui décrit les notes d’évaluation des films et séries disponibles sur diverses plateformes de diffusion en continu. Le fichier est issu du site Kaggle. Voici la présentation du jeu de données : Title : titre de la série ou du film Year : Année de sortie ou première diffusion Age : Type de public conseillé IMDb : Notes des utilisateurs enregistrés sur le site L’Internet Movie Database Rotten.Tomatoes : Notes basées sur les opinions de centaines de critiques de cinéma et de télévision du site du même nom Netflix : si le film ou la série est disponible sur cette plateforme Hulu : si le film ou la série est disponible sur cette plateforme Prime.Video : si le film ou la série est disponible sur cette plateforme Disney. : si le film ou la série est disponible sur cette plateforme df &lt;- read.csv(file = &quot;dataset/tv_shows.csv&quot;, sep = &quot;,&quot;, dec = &quot;,&quot;) dim(df) ## [1] 5611 9 Title Year Age IMDb Rotten.Tomatoes Netflix Hulu Prime.Video Disney. Breaking Bad 2008 18+ 9.5 0.96 1 0 0 0 Stranger Things 2016 16+ 8.8 0.93 1 0 0 0 Money Heist 2017 18+ 8.4 0.91 1 0 0 0 Sherlock 2010 16+ 9.1 0.78 1 0 0 0 Better Call Saul 2015 18+ 8.7 0.97 1 0 0 0 The Office 2005 16+ 8.9 0.81 1 0 0 0 Black Mirror 2011 18+ 8.8 0.83 1 0 0 0 Supernatural 2005 16+ 8.4 0.93 1 0 0 0 Peaky Blinders 2013 18+ 8.8 0.92 1 0 0 0 Avatar: The Last Airbender 2005 7+ 9.2 1 1 0 0 0 The Walking Dead 2010 18+ 8.2 0.81 1 0 0 0 Dark 2017 16+ 8.7 0.94 1 0 0 0 Ozark 2017 18+ 8.4 0.81 1 0 0 0 Attack on Titan 2013 16+ 8.8 0.94 1 1 0 0 Narcos 2015 18+ 8.8 0.89 1 0 0 0 Fullmetal Alchemist: Brotherhood 2009 18+ 9.1 1 1 1 0 0 Community 2009 7+ 8.5 0.88 1 1 0 0 Mindhunter 2017 18+ 8.6 0.96 1 0 0 0 Parks and Recreation 2009 16+ 8.6 0.93 1 1 1 0 Dexter 2006 18+ 8.6 0.72 1 0 0 0 "],
["biblio.html", "Chapitre 15 Bibliographie", " Chapitre 15 Bibliographie Voici les références qui ont permis de construire ce livre : Julien Barnier, “Introduction à R et au tidyverse” Cours SQL sur le site sql.sh "]
]
