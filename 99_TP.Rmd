# S'entrainer {#entrainement}

## TP1

**Difficult√© üèÜ**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readxl)
library(dplyr)
library(knitr)
library(kableExtra)
taille <- 12
```

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 et 3.
On utilise  le dataset `mtcars` qui d√©crit les statistiques de voitures.
Le dataset est pr√©sent dans le package *datasets* automatiquement install√© sur R. Voici une description des donn√©es :

-	`mpg`	: Miles/(US) gallon
-	`cyl`	: Number of cylinders
-	`disp` :	Displacement (cu.in.)
-	`hp` :	Gross horsepower
-	`drat` :	Rear axle ratio
-	`wt` :	Weight (1000 lbs)
-	`qsec` :	1/4 mile time
-	`vs` :	Engine (0 = V-shaped, 1 = straight)
-	`am` :	Transmission (0 = automatic, 1 = manual)
-	`gear` :	Number of forward gears
-	`carb` :	Number of carburetors

```{r, echo=FALSE, warning=FALSE, message=FALSE}
df <- mtcars
kable(head(df,n = 10), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```

<br>

**Exercice 1 : Pr√©parer son environnement de travail**

a. Dupliquer le dataset dans un nouvel objet appel√© `df`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?
c. Affichez le nom des colonnes
d. Affichez le type des colonnes avec la fonction adapt√©e.
e. On souhaite analyser les variables `cyl`, `vs`, `am`, `gear` et `carb` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont pr√©sents dans ces variables ?
g. Affichez un r√©sum√© des donn√©es avec la fonction adapt√©e.

**Exercice 2 : Statistiques descriptives**

a. D√©terminer la moyenne de la variable `mpg`
b. D√©terminer le maximum la variable `wt`.
c. D√©terminer la m√©diane de la variable `hp`.
d. D√©terminer les quartiles de la variable `qsec`.
e. D√©terminer les d√©ciles de la variable `qsec`.
f. D√©terminer la variance et l'√©cart-type de la variable `qsec`.
g. D√©terminer un tri √† plat pour compter les effectifs des modalit√©s de chaque variables *factor*.

**Exercice 3 : Quelques graphiques**

a. Contruire un histogramme de la distribution de la variable `qsec`.
b. Constuire une bo√Æte √† moustache de la distribution de la variable `qsec`.
c. Construire un diagramme en barre de r√©partition de la variable `carb`.
d. Construire un diagramme circulaire de la r√©partition de la variable `vs`.

**Exercice 4 : Cr√©ation de nouvelles colonnes**

a. La colonne `mpg` correspond au nombre de miles parcouru en 1 gallon (US). Cette mesure correspond en quelques sortes √† la mesure de consommation de litres aux 100 km utilis√©e en France. Cr√©er une colonne suppl√©mentaire appel√©e `litres_au_100km` qui correspond √† la conversion de la variable `mpg`(Miles/(US) gallon) en nombre de litres aux 100 kilom√®tres. Aidez-vous du guide des conversion disponible sur ce [lien](https://anglais-pratique.fr/index.php/rubriques/divers/101-mpg-l-100km).
b. Construire une nouvelle colonne appel√©e `qsec_cut` qui est un d√©coupage de la variable `qsec` en 3 groupes (pas de restriction sur le nombre de classe).
c. Construire une nouvelle colonne appel√©e `litres100km_group` pour distinguer deux groupes de voiture : celles qui consomment plus que la moyenne et celles qui consomment moins que la moyenne.

## TP2

**Difficult√© üèÜüèÜ**

<p>
![Pokemon](./img/pokemon.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 √† 5.
On utilise  le fichier `pokemon.xlsx` qui d√©crit les statistiques des pokemon des deux premi√®res g√©n√©rations.
Le fichier est issu du site [ Kaggle ](https://www.kaggle.com/rounakbanik/pokemon). Il a √©t√© adapt√© pour ce TP. Pour r√©aliser ce TP, t√©l√©charger le fichier en [cliquant ici](https://github.com/asardell/programmation-r/tree/master/dataset).Voici une description des donn√©es :

- `pokedex_number` : num√©ro du pokemon
- `nom` : nom du pokemon
- `generation` : le num√©ro de g√©n√©ration dont est issu le pokemon
- `is_legendary` : Oui / Non si le pokemon est l√©gendaire
- `type` : le type du pokemon
- `weight_kg` : le poids du pokemon en kg
- `height_m` : la taille du pokemon en m√®tre
- `attack` : la puissance d'attaque du pokemon
- `defense` : la puissance de d√©fense du pokemon
- `speed` : la vitesse du pokemon


```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readxl)
pokemon <- read_excel(path = "./dataset/pokemon.xlsx", sheet = "pokemon")
kable(head(pokemon,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Importer les donn√©es**

a. Importez le jeu de donn√©es `pokemon.xlsx` √† l'aide du package `readxl`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?
c. Affichez le nom des colonnes.
d. Affichez le type des colonnes avec la fonction adapt√©e.
e. On souhaite analyser les variables `generation`, `is_legendary`, et `type` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont pr√©sents dans ces variables ?
g. Affichez un r√©sum√© des donn√©es avec la fonction adapt√©e.


**Exercice 2 : Statistiques descriptives**

a. D√©terminer la moyenne de la variable `weight_kg`.
b. D√©terminer la m√©diane de la variable `weight_kg`.
d. D√©terminer les quartiles de la variable `height_m`.
e. D√©terminer les d√©ciles de la variable `height_m`.
f. D√©terminer la variance et l'√©cart-type de la variable `weight_kg`.
g. D√©terminer un tri √† plat pour compter les effectifs des modalit√©s de chaque variable *factor* en triant chaque sortie par ordre d√©croissant.

**Exercice 3 : Tris et Selections**

Pour chaque question suivante, affectez le r√©sultat de la requ√™te dans un objet puis calculez sa dimension. Exemple :

```{r}
#Selectionnez les deux premi√®res colonnes du data frame
requete_0 <- pokemon[,1:2]
dim(requete_0)
```

a. S√©lectionnez la colonne `nom` et `is_legendary`.
b. S√©lectionnez les 50 premi√®res lignes et les deux premi√®res colonnes.
c. S√©lectionnez les 10 premi√®res lignes et toutes les colonnes.
d. S√©lectionnez toutes les colonnes sauf la derni√®re.
e. S√©lectionnez les colonnes 2,8,9 et 10.
f. S√©lectionnez les lignes 20 √† 30 et 80 √† 100.
g. Triez le dataset  par ordre alphab√©tique et afficher le `nom` du pokemon dela premi√®re ligne.
h. Triez le dataset  par `weight_kg` en ordre **d√©croissant**, et afficher le `nom`du pokemon de la premi√®re ligne
i. Triez le dataset  par `attack` en ordre **d√©croissant** puis par `speed` en ordre **croissant**, et afficher le `nom` des pokemons des 10 premi√®res lignes.


**Exercice 4 : Tris et Filtres**

Pour chaque question suivante, affectez le r√©sultat de la requ√™te dans un objet puis calculez sa dimension. Pour faciliter la lecture, s√©lectionnez la colonne `nom`et les colonnes concern√©es par le filtre. Exemple :

```{r}
#Selectionnez les pokemons de type feu
requete_0 <- pokemon[ pokemon$type == "fire", c("nom","type")]
dim(requete_0)
```
a. Filtrez sur les pokemons qui ont 150 ou plus d'`attack` puis trier le r√©sultat par ordre d√©croissant d'`attack`. 
b. Filtrez sur les pokemons de `type` *dragon*,*ghost*,*psychic* et *dark*
c. Filtrez sur les pokemons de `type` *fire* avec plus de 100 d'`attack`, puis trier le r√©sultat par ordre d√©croissant d'`attack`. 
d. Filtrez sur les pokemons qui ont entre 100 et 150 de `speed`. Les trier par `speed` d√©croissant.
e. Filtrez sur les pokemons pesant plus de 250 kg et affichez le r√©sultat pour v√©rifier.
f. Filtrez sur les pok√©mons qui ont des valeurs manquantes sur la variable `height_m`.
g. Filtrez sur les pokemons qui ont des valeurs renseign√©es √† la fois pour la variable `weight_kg` **et** la variable `height`.


**Exercice 5 : Agregations**

Pour chaque question suivante, affectez le r√©sultat de la requ√™te dans un objet puis calculez sa dimension. Exemple :

```{r}
#Calculez la vitesse moyenne par generation
requete_0 <- aggregate(x = speed ~ generation, data = pokemon , FUN = mean)
dim(requete_0)
```

```{r, echo=FALSE}
kable(requete_0)
```

a. Calculez l'`attack` moyenne en fonction de la variable `type`, puis filtrez sur les 3 types avec les moyennes les plus √©lev√©es.
b. Calculez le nombre de pokemon par `type` , puis triez par ordre d√©croissant ces effectifs.
c. Calculez la m√©diane de `weight_kg` par `type`.
d. Calculez le nombre de pokemon par `type` et `generation`
e. Calculez la moyenne de chaque crit√®re (`weight_kg`, `height_m`, `attack`, `defense` et `speed`) en fonction de chaque `type`.

## TP3

**Difficult√© üèÜüèÜüèÜ**

<p>
![Among us](./img/amongus.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 6,7 et 10.
On utilise le fichier compress√© `AmongUs.7z` o√π l'ensemble des fichiers d√©crivent les statistiques des parties jou√©es sur le jeu *Among Us*. Il y a un fichier par joueur nomm√© *UserX.csv*.
Les donn√©es sont issues du site [Kaggle](https://www.kaggle.com/ruchi798/among-us-dataset). Pour r√©aliser ce TP, t√©l√©charger le fichier en [cliquant ici](https://github.com/asardell/programmation-r/tree/master/dataset).
Les fichiers csv ont tous la m√™me structure avec :

- `Game.Completed.Date` : Date de la partie
- `Team` : l'√©quipe attribu√©e
- `Outcome` : r√©sultat de la partie
- `Task.Completed` : le nombre de t√¢ches effectu√©es
- `All.Tasks.Completed` : si toutes les t√¢ches ont √©t√© effectu√©es
- `Murdered` : si le joueur a √©t√© tu√©
- `Imposter.Kills` : le nombre de joueurs tu√©s par l'imposteur
- `Game.Length` : dur√©e de la partie
- `Ejected` : si le joueur a √©t√© √©limin√© par les autres au cours de la partie
- `Sabotages.Fixed` : nombre de sabotages r√©par√©s
- `Time.to.complete.all.tasks` : temps pour compl√©ter les toutes les t√¢ches
- `Rank.Change`  : Non renseign√©
- `Region.Game.Code` : la r√©gion du serveur de jeu


```{r, echo=FALSE, warning=FALSE, message=FALSE}
AmongUs <-read.csv("./dataset/AmongUs.csv")
kable(head(AmongUs,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Cr√©er le jeu de donn√©es**

a. T√©l√©charger le fichier compress√© `AmongUs.7z` et le d√©ziper. La fonction `list.files()` devrait vous aider √† extraire l'ensemble des noms de fichiers pr√©sents dans un r√©pertoire (voir l'exemple ci-dessous).

```{r}
list.files(path = "dataset/", pattern="*.csv", full.names=FALSE)
```

b. Compiler l'ensemble des fichiers *UserX.csv* pr√©sents dans le fichier zip dans un seul et m√™me data frame. Utiliser une boucle qui parcourt chaque fichier csv utilisateur. La fonction `rbind()` devrait vous aider √† compiler les diff√©rents csv dans un seul data frame (voir l'exemple ci-dessous). 
<br> 
üì¢ Attention, pour le bon d√©roulement du TP, int√©grer l'argument `stringsAsFactors = FALSE` dans votre fonction `read.csv()`. Cet argument permet de ne pas typer par d√©faut les variables `character` en `factor` lors de l'importation.

```{r}
df <- data.frame()
dim(df)
df <- rbind(df, mtcars)
dim(df)
df <- rbind(df, mtcars)
dim(df)
```

c. Modifier votre boucle afin d'ajouter une colonne dans le data frame final qui renseigne le num√©ro d'utilisateur disponible dans le nom de chaque fichier csv.
<br>
üí° indice : Il est plus simple d'ajouter une colonne avec le nom du fichier juste avant la fonction `rbind()`.

d. Stocker le data frame final dans un objet appel√© *AmongUs*.

e. Supprimer la colonne `Rank.Change` qui est inutile.

f. On observe des valeurs manquantes dans le dataset √† travers les champs `-` et `N/A`, on souhaite remplacer ces valeurs textuelles par la v√©ritable valeur `NA` permettant d'indiquer √† R que la valeur est manquante. Construire une fonction appel√©e `manage_na()` qui prend en entr√©e :

* un vecteur `x` correspondra √† une colonne d'un dataset.
* un vecteur `string_to_na` correspondant √† la liste des cha√Ænes de caract√®res qu'on souhaite transformer en `NA`.

La fonction retournera le vecteur modifi√©.
<br>
üí° indice : voici ci-dessous la t√™te que doit avoir votre fonction :

```{r, eval=FALSE}
manage_na <- function(x, string_to_na) {
  
  ...
  ...
  ...
  
  return(x_modif)
}
```


g. Construire une boucle qui parcourt toutes les colonnes du data frame *AmongUs* et qui remplace les champs avec des `-` et `N/A` par des valeurs manquantes `NA`. Utilisez la fonction `manage_na()` cr√©√©e pr√©c√©demment.


**Exercice 2 : Manipuler le texte et les dates**

a. √Ä partir de la colonne `Game.Completed.Date`, construire une colonne appel√©e `Date` avec la date de la partie au format *yyyy-mm-dd* uniquement. Veiller √† ce que le type de cette colonne soit *Date*.

b. √Ä partir de la colonne `Game.Completed.Date`, construire une colonne appel√©e `Heure` avec **l'heure uniquement** de la partie. Attention au format *am* et *pm*. 

c. √Ä partir de la colonne `Game Length`, construire une colonne appel√©e `Game.Length.sec` correspondant √† la dur√©e de la partie en secondes. 

d. √Ä partir de la colonne `Time.to.complete.all.tasks`, construire une colonne appel√©e `Complete.all.tasks.sec` correspondant √† la dur√©e en secondes pour compl√©ter toutes les t√¢ches.

e. √Ä partir de la colonne `Region.Game.Code` construire une colonne appel√©e `Region` correspondant au nom du continent uniquement.

**Exercice 3 : Type des variables**

a. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (Utiliser la fonction adapt√©e) ?

b. Afficher un r√©sum√© des donn√©es avec la fonction adapt√©e. 

c. Veiller √† ce que les types de chaque colonne du dataset correspondent aux types ci-dessous. Sinon, convertir les variables dans leur type appropri√©.

Variable | Type souhait√©
------------ | ------------
Game.Completed.Date | character
Team | factor
Outcome| factor
Task.Completed| numeric
All.Tasks.Completed| factor
Murdered| factor
Imposter.Kills| numeric
Game.Length| character
Ejected| factor
Sabotages.Fixed| numeric 
Time.to.complete.all.tasks| character
Region.Game.Code| character
**Date** | Date
**Heure** | numeric
**Game.Length.sec** | numeric
**Complete.all.tasks.sec** | numeric
**Region** | factor

<br>
üì¢ Attention, lorsqu'on convertit un vecteur de type `factor` en type `numeric`, il est recommand√© de passer d'abord par le type `character` (voir exemple ci-dessous). Ce ne sera peu √™tre pas utile pour ce TP, mais c'est bien de le savoir !

Ce qu'il ne faut pas faire ‚õî
```{r}
x <- factor(c(7,7,8,7,9,6,6))
levels(x)
x <- as.numeric(x)
x
```
Ce qu'il faut faire ‚úÖ
```{r}
x <- factor(c(7,7,8,7,9,6,6))
levels(x)
x <- as.numeric(as.character(x))
x
```
e. V√©rifier si cela a fonctionn√© en affichant le type de chaque variable du data frame.
 
 
**Exercice 4 : Analyses statistiques **

La plupart des questions de cet exercice demandent un peu de r√©flexion. <br>
üì¢ Ne partez pas √† l'abordage, les solutions peuvent se coder en plusieurs √©tapes (*tris*,*filtres*, *agregations*, *etc.*).

a. Quelle est la dur√©e moyenne d'une partie ? 

b. Combien y-a-t-il de r√©gions serveurs diff√©rentes ?.

c. Combien de t√¢che maximum un Crewmate peut-il r√©aliser ?

d. Quel est le taux de parties remport√©es par les imposteurs ?

e. Construire **un graphique adapt√©** permettant de visualiser la r√©partition du nombre de parties jou√©es selon la`Region`.

f. Construire **un graphique adapt√©** permettant de visualiser la r√©partition des joueurs qui termine ou pas leurs t√¢ches selon s'ils se font tuer ou pas.

g. Construire **un graphique adapt√©** permettant de visualiser la distribution du nombre de t√¢ches compl√©t√©es par les joueurs.

h. Construire **un graphique adapt√©** permettant de visualiser pour chaque partie jou√©e, la dur√©e de la partie et le temps pour compl√©ter toutes les t√¢ches.

i. Construire **un graphique adapt√©** permettant de visualiser la distribution du temps des parties selon la `Region`.

j. Construire **un graphique adapt√©** permettant de visualiser l'√©volution du nombre de parties jou√©es selon l'heure de la journ√©e.

k. Construire **un graphique adapt√©** permettant de visualiser les variations du taux de succ√®s des imposteurs selon les r√©gions serveurs.

l. Construire **un graphique adapt√©** permettant de visualiser les taux de succ√®s  des 5 meilleurs utilisateurs.


## TP4

**Difficult√© üèÜüèÜ**

<p>
![NBA](./img/nba.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 √† 7.
On utilise  le fichier `NBA.csv` qui d√©crit les tirs effectu√©s au cours de la saison 2014-2015 de NBA. Le fichier est issu du site [ Kaggle ](https://www.kaggle.com/dansbecker/nba-shot-logs). Il a √©t√© adapt√© et modifi√© pour ce cours. Les donn√©es sont accessibles en [cliquant ici](https://github.com/asardell/programmation-r/tree/master/dataset).

Voici la pr√©sentation du jeu de donn√©es :

- `GAME_ID` : ID du match
- `LOCATION` : Lieu du match (*Home* / *Away*)
- `GAME_RESULT` : R√©sultat du match (*Won* / *Lost*)
- `PERIOD` : Num√©ro de quart-temps et prolongations √©ventuelles
- `SHOT_CLOCK` :  Dur√©e de la possession de l'√©quipe au moment du tir
- `DRIBBLES` : Nombre de dribbles avant le tir
- `TOUCH_TIME` : Dur√©e de la possession du joueur avant le tir
- `SHOT_DIST` : Distance de tir en *foot* (*1 foot = 0,30 m√®tre*)
- `PTS_TYPE` : Tentative √† 2 ou 3 points (les lancers francs √† 1 point ne sont pas r√©pertori√©s)
- `SHOT_RESULT` : R√©sultat du tir (*made* / *missed*)
- `CLOSE_DEF_DIST` : Distance entre le tireur et le d√©fenseur le plus proche en *foot* (*1 foot = 0,30 m√®tre*)
- `SHOOTER` : Nom du tireur

```{r, echo =FALSE, warning=FALSE, message=FALSE}
NBA <- read.csv("./dataset/NBA.csv")
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
kable(head(NBA,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>
**Exercice 1 : Importer les donn√©es**

a. Importer le jeu de donn√©es `NBA.csv` avec la fonction `read.csv()`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?
c. Afficher le nom des colonnes.
d. Afficher le type des colonnes avec la fonction adapt√©e.
e. On souhaite analyser les variables `PERIOD`, `PTS_TYPE`, et `SHOOTER` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont pr√©sents dans ces variables ?
g. Afficher un r√©sum√© des donn√©es avec la fonction adapt√©e.

**Exercice 2 : Statistiques descriptives**

a. Calculer l'√©cart-type de la variable pr√©sentant la distance de tir (`SHOT_DIST`).
b. Calculer l'√©cart-type de la variable pr√©sentant la dur√©e de la possession de l'√©quipe au moment du tir (`SHOT_CLOCK`).
c. Calculer la r√©partition du nombre de tirs manqu√©s et r√©ussis (`SHOT_RESULT`).
d. Calculer les **quartiles** de la variable pr√©sentant le nombre de dribbles avant un tir (`DRIBBLES`).
e. Calculer les **d√©ciles** de la variable pr√©sentant la distance entre le tireur et le d√©fenseur le plus proche (`CLOSE_DEF_DIST`).
f. Combien de matchs se sont d√©roul√©s lors de cette saison de basket ?
g. Combien y-a-t-il de `SHOOTER` diff√©rents ?

**Exercice 3 : Modifier le jeu de donn√©es**

a. Cr√©er une variable `SHOT_DIST_METRE` qui affiche la variable `SHOT_DIST` convertit en m√®tre (*1 foot = 0,30 m√®tre*).
b. Cr√©er une variable `PTS_MARQUES` qui prend la valeur 0, 2 ou 3 en fonction de l'issue du tir.
c. Supprimer la variable `GAME_RESULT` car elle est inutile.

**Exercice 4 : Interroger les donn√©es**

Attention, certaines questions peuvent n√©cessiter plusieurs √©tapes.  Penser √† v√©rifier vos requ√™tes avec la fonction `dim()` ou `View()`.Pour chaque question, affecter le r√©sultat ddans un objet comme dans l'exemple ci-dessous.

```{r}
#Selectionnez les deux premi√®res colonnes du data frame
requete_0 <- NBA[, c(1,2)]
```

a. On souhaite extraire uniquement la colonne `SHOOTER` , `SHOT_RESULT` et `PTS_TYPE` dans cet ordre.
b. On souhaite extraire uniquement les 50 premi√®res lignes.
c. On souhaite extraire toutes les colonnes sauf la premi√®re.
d. On souhaite extraire uniquement les 100 **tirs tent√©s** avec les `SHOT_DIST` les plus loin.
e. On souhaite extraire uniquement les 100 **tirs r√©ussis** avec les `SHOT_DIST` les plus loin.
f. On souhaite extraire uniquement les tirs r√©ussis √† 3 points de *kobe bryant*.
g. On souhaite construire un data frame avec les 5 `SHOOTER` qui ont inscrit le plus de points.

**Bonus**

On souhaite construire un programme permettant de parcourir l'ensemble des colonnes du data frame :

* Si la colonne est `numeric`,on souhaite construire un *boxplot*.
* Si la colonne est `factor`, on souhaite construire un *barplot*.
* Sinon, on ne fait rien.

- Pensez √† ajouter un titre sur les graphiques afin de savoir √† quelle variable on a √† faire.
- Dans une boucle,lorsqu'on souhaite affcher un graphique ou une sortie dans la console, il faut utiliser la fonction `print()`.

## TP5 - Chercher l'erreur

**Difficult√© üèÜüèÜ**

<p>
![mistake](./img/mistake.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 √† 7. Dans ce TP, vous incarnez un data analyst travaillant dans le service statistique de la NBA. Un de vos coll√®gues est parti en vacances vendredi dernier et a envoyer √† votre manager quelques statistiques sur les tirs effectu√©s au cours de la saison 2014-2015. <br>
Le probl√®me c'est que le script est bourr√© de fautes ! Rien ne fonctionne, √† tous les coups, votre coll√®gue √©tait press√© de partir en vacance. Votre manager fait donc appel √† vous pour corriger les erreurs de ce script. Attention, votre manager aimerait √©galement comprendre ce que vous programmez dans votre script alors n'oubliez pas de commenter chaque ligne de code pour qu'il la comprenne. Le fichier de donn√©es (*NBA.csv*) et le script de votre coll√®gue (*nba_stats.R*) sont disponibles en [cliquant ici](https://github.com/asardell/programmation-r/tree/master/dataset).
<br>
üéØ Votre manager a d√©j√† pass√© beaucoup de temps pour comprendre ce script et aimerait que votre correction garde la m√™me philosophie que le script de votre coll√®gue, cela signifie qu'il ne faut pas √©crire d'autres commandes R et simplement faire en sorte que celles d√©j√† pr√©sentes fonctionnent.


<p>
![script1](./img/mistakes_1.PNG)
</p>

<p>
![script2](./img/mistakes_2.PNG)
</p>

<p>
![script3](./img/mistakes_3.PNG)
</p>

<p>
![script4](./img/mistakes_4.PNG)
</p>


## TP6 - Analyses statistiques

**Difficult√© üèÜüèÜ**

<p>
![Students](./img/students.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 √† 5.
On utilise le fichier `students_results.csv` qui d√©crit les notes d'√©tudiants sur diff√©rentes √©preuves.
Pour r√©aliser ce TP, t√©l√©charger le fichier en [cliquant ici](https://github.com/asardell/programmation-r/tree/master/dataset). Voici une description des donn√©es :


- `ID_etudiant` : Le matricule des √©tudiants
- `Genre` : Le genre des √©tudiants
- `Groupe.TP` : Le groupe de travaux pratiques
- `Groupe.TD` : Le groupe de travaux dirig√©s
-  `QUIZ#` : Le score du quiz num√©ro #
- `TP#` : La note au TP num√©ro #


```{r, echo=FALSE, warning=FALSE, message=FALSE}
df <- read.csv(file = "dataset/students_results.csv",
                               sep = ";", dec = ",")
kable(head(df,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Importer les donn√©es**

a. Importer le jeu de donn√©es `students_results.csv` avec la fonction `read.csv()`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?
c. Afficher le nom des colonnes.
d. Afficher le type des colonnes avec la fonction adapt√©e.
e. Afficher un r√©sum√© des donn√©es avec la fonction adapt√©e.
f. On souhaite analyser les variables `Groupe.TP` et `Groupe.TD` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.

**Exercice 2 : Statistiques descriptives**

a. Ajouter une colonne appel√©e `TOTAL_QUIZ` qui correspond √† la somme des notes des quiz.
```{r, echo=FALSE}
df$TOTAL_QUIZ <- df$QUIZ1 + df$QUIZ2
```
b. D√©terminer la moyenne du score total des quiz. Proposez un graphique adapt√© pour visualiser la distribution de tous les scores totaux des √©tudiants
c. D√©terminer les d√©ciles des notes du TP4. Proposez un autre graphique pour visualiser la distribution des notes des √©tudiants au TP4.
d. D√©terminer le nombre d'√©tudiants par groupe de TP. Proposez un graphique adapt√© pour visualiser cette r√©partition par groupe.
e. D√©terminer le nombre d'√©tudiants par genre. Proposez un autre graphique pour visualiser cette r√©partition par genre.

**Exercice 3 : Qui sont les meilleurs ?**

a. Proposer un graphique adapt√© pour visualiser la distribution du score total aux quiz par genre.
b. Calculer la moyenne du score total aux quiz par genre
c. Proposer un graphique adapt√© pour visualiser la distribution du score total aux quiz par groupe de TP.
d. Calculer la moyenne du score total aux quiz par groupe de TP.
e. On souhaite visualiser avec un graphique adapt√© le score total aux quiz uniquement des 5 meilleurs √©tudiants.
f. On souhaite conserver les lignes uniquement des 3 meilleur(e)s √©tudiant(e)s du groupe de TP 1.


**Exercice 4 : Allez plus loin **


Dans cet exercice, nous allons aller plus loin sur des notions qu'on peut retrouver en analyses statistiques comme des corr√©lations et des r√©gressions lin√©aires. On va d√©terminer quelle variable est la plus corr√©l√©e avec la note du TP4 qui a √©t√© r√©alis√© en condition d'examen. Puis nous mod√©liserons cette relation.


a. Y-a-t-il une corr√©lation entre la note au TP4 et le score total aux quiz ? Pour cela, utiliser la fonction `cor()`. Voici un exemple d'utilisation avec le dataset `iris` ci-dessous:

```{r, eval=FALSE,warning=FALSE, message=FALSE}
help("cor")
```

```{r, warning=FALSE, message=FALSE}
cor(x = iris$Sepal.Length, y = iris$Sepal.Width)
```

b. On peut aussi utiliser la fonction `cor()` o√π l'argument `x` est un data frame avec uniquement les variables quantitatives qu'on souhaite analyser. Cela permet d'obtenir ce qu'on appelle une matrice de corr√©lation. Voici ci-dessous un exemple d'utilisation avec le dataset `iris`.  Construire la matrice de corr√©lation des scores aux quiz et des notes des TP. 

```{r}
#On construit la matrice de corr√©lation sur le dataset iris en excluant la colonne 5 qui est qualitative
cor(iris[ , -5])
```
```{r, echo=FALSE}
cor_matrix <- cor(df[ , 5:10], use = "complete.obs")
```

c. La fonction `corrplot()` du package `corrplot` du m√™me nom permet de visualiser une matrice de corr√©lation. Ce graphique s'appelle aussi un *corr√©logramme*. Construire un *corrplot* de la matrice de corr√©lation calcul√©e pr√©c√©demment. Consulter cette [page](http://www.sthda.com/french/wiki/visualiser-une-matrice-de-correlation-par-un-correlogramme) pour plus d'information. En le personnalisant, on peut obtenir le corr√©logramme ci-dessous :
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(corrplot)
corrplot(cor_matrix, type="upper", tl.srt=45, 
         addCoef.col = "black", diag = FALSE)
```


d. Quelle est la variable la plus corr√©l√©e avec la note au TP4 ?

e. Pour illustrer cette corr√©lation, construire un nuage de points des notes du TP4 en fonction de la variable la plus corr√©l√©e comme ci-dessous :

```{r, echo=FALSE}
plot(x = df$TP2, y = df$TP4,
     pch = 19, cex = 1.5,
     xlim = c(0,1), ylim = c(0,20),
     col = rgb(0,0,1,alpha = 0.25),
     xlab = "x", ylab = "TP4",
     main = "Note du TP4 en fonction de la variable x")
```


f. On observe une relation lin√©aire entre ces deux variables. On va calculer la droite qui permet de mod√©liser cette relation On parle alors de droite de r√©gression. Cette m√©thode permet d'√©tablir une relation math√©matique entre une variable explicative $x$ et une variable √† expliquer $y$ telles que $y = ax + b$  o√π :

* $a$ est le coefficient directeur aussi appel√© *la pente*.
* $b$ est la constante o√π la valeur de l'ordonn√©e $y$ lorsque l'abscisse $x$ vaut 0.

Voici un exemple :
<p>
![lm](./img/linear_reg.png)
</p>


Calculer ces deux indicateurs sachant que :

* $a = \frac{s_{xy}}{s^2_x}$ o√π $s_{xy}$ est la covariance entre $x$ et $y$ et $s^2_x$ est la variance de la variable explicative. On peut la calculer avec la fonction `cov()`.

* $b=\bar{y}-a\bar{x}$ o√π $\bar{x}$ et $\bar{y}$ correspondent respectivement √† la moyenne de la variable explicative et la variable √† expliquer.

üì¢ Il est recommand√© de calculer ces indicateurs sur un tableau filtr√© avec uniquement les lignes ne pr√©sentant pas de valeurs manquantes sur la variable explicative et la note au TP4.

```{r,echo=FALSE}
dfnotNA <- na.exclude(df[, c("TP2","TP4")])
a = cov(x = dfnotNA$TP4, 
        y = dfnotNA$TP2)/var(dfnotNA$TP2)

#on arrondie
a <- round(a,2)

x <- mean(dfnotNA$TP2)
y <- mean(dfnotNA$TP4)

b <- y - a*x

#on arrondie
b <- round(b,2)
print(paste("Le coefficient directeur a vaut" , a))
print(paste("La constante b vaut" , b))
```
g. Apr√®s avoir calcul√© $a$ et $b$, Tracer la droite de r√©gression sur le nuage de points avec la fonction `abline()`.

```{r, eval=FALSE,warning=FALSE, message=FALSE}
help("abline")
```

```{r, echo=FALSE}
plot(x = df$TP2, y = df$TP4,
     pch = 19, cex = 1.5,
     xlim = c(0,1), ylim = c(0,20),
     col = rgb(0,0,1,alpha = 0.25),
     xlab = "x", ylab = "TP4",
     main = "Note du TP4 en fonction de la variable x")

abline(a = b,b = a, lwd = 3, col = "red")
legend("topleft", legend = paste("y = ",a,"x +",b),
       col = "red", lty = 1, lwd = 2)
```


h. En r√©alit√©, pour √©viter tous ces calculs, on peut directement utiliser la fonction `lm()` qui g√®re d√©j√† les valeurs manquantes.

```{r, eval=FALSE,warning=FALSE, message=FALSE}
help("lm")
```

```{r}
modele <- lm(TP4 ~ TP2, data = df)
modele$coefficients
```

```{r}
plot(x = df$TP2, y = df$TP4,
     xlim = c(0,1), ylim = c(0,20),
     xlab = "TP2", ylab = "TP4",
     main = "Note du TP4 en fonction de la note du TP2")

abline(modele)
```


## TP7 - Analyse de film

**Difficult√© üèÜüèÜ**

<p>
![Streaming](./img/streaming.png)

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 √† 6.
On utilise  le fichier `tv_shows.csv` qui d√©crit les notes d'√©valuation des films et s√©ries disponibles sur diverses plateformes de diffusion en continu. Le fichier est issu du site [Kaggle ](https://www.kaggle.com/ruchi798/tv-shows-on-netflix-prime-video-hulu-and-disney). Il a √©t√© adapt√© pour ce TP. Pour r√©aliser ce TP, t√©l√©charger le fichier en [cliquant ici](https://github.com/asardell/programmation-r/tree/master/dataset).Voici une description des donn√©es :

- `Title` : titre de la s√©rie ou du film
- `Year` : Ann√©e de sortie ou premi√®re diffusion
- `Age` : Type de public conseill√©
- `IMDb` : Notes des utilisateurs enregistr√©s sur le site [*L'Internet Movie Database*](https://www.imdb.com/)
- `Rotten.Tomatoes` : Notes bas√©es sur les opinions de centaines de critiques de cin√©ma et de t√©l√©vision du [site](https://www.rottentomatoes.com/) du m√™me nom
- `Netflix` : si le film ou la s√©rie est disponible sur cette plateforme
- `Hulu` : si le film ou la s√©rie est disponible sur cette plateforme
- `Prime.Video` : si le film ou la s√©rie est disponible sur cette plateforme
- `Disney.` : si le film ou la s√©rie est disponible sur cette plateforme


**Exercice 1 : Importer les donn√©es**

a. Importer le jeu de donn√©es `tv_shows.csv` avec la fonction `read.csv`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez la ou les fonctions adapt√©es) ?
c. Afficher le nom des colonnes.
d. Afficher un r√©sum√© des donn√©es avec la fonction adapt√©e.
e. On souhaite analyser les variables `Year`en tant que variable qualitative. Modifier le type de cette variable pour la transformer en type factor.
f. Afficher le type de chaque variable avec la fonction adapt√©e.
g. Construire une colonne appel√©e `Total_plateforme` avec le nombre de plateforme o√π est disponible le film ou la s√©rie.


**Exercice 2 : Statistiques descriptives**

üë®üèª‚Äçüè´ Ne pas oublier de mettre des titres sur vos graphiques !

a. D√©terminer la moyenne des notes `IMDb`.
b. D√©terminer le nombre de modalit√©s de type de public conseill√© (variable `Age`).
c. D√©terminer les **centiles** des notes `Rotten.Tomatoes`.
d. D√©terminer l'√©cart-type des notes `IMDb` puis  `Rotten.Tomatoes`.
e. Repr√©senter graphiquement la distribution des notes utilisateurs (variable `IMDb`).
f. D√©terminer un tri √† plat pour compter les effectifs des modalit√©s de type de public conseill√© (variable `Age`).
g. Repr√©senter graphiquement ce tri √† plat de la modalit√© la plus repr√©sent√©e √† la moins repr√©sent√©e.
h. Calculer la r√©partition en pourcentage du nombre de films ou s√©ries pr√©sents sur la plateforme Netflix.
i. Repr√©senter graphiquement cette r√©partition dans un diagramme circulaire.
j. Repr√©senter graphiquement la distribution des notes utilisateurs (variable `IMDb`) selon le type de public conseill√© (variable `Age`).


**Exercice 3 : Tris, filtres et agr√©gations**

üí° On peut v√©rifier si la question est correcte en affichant le r√©sultat dans une vue. 

a. Construire un objet `requete_a` avec uniquement les films grands public (variable `Age` : *all*). Puis les trier de la note utilisateur (variable `IMDb`) de la plus √©lev√©e √† la plus basse.

b. Construire un objet `requete_b` avec uniquement les films ayant une note utilisateur (variable `IMDb`) sup√©rieure ou √©gale √† 9. Puis les trier par ann√©e de sortie de la plus ancienne √† la plus r√©cente

c. Construire un objet `requete_c` avec uniquement les films ayant une note utilisateur (variable `IMDb`) et une note critique (variable `Rotten.Tomatoes`) qui soient renseign√©es. Puis les trier par ordre alphab√©tique (de A √† Z)

d. Construire un objet `requete_d` avec la moyenne des notes utilisateurs (variable `IMDb`) selon le type de public conseill√© (variable `Age`). Puis les trier de la note utilisateur (variable `IMDb`) de la plus √©lev√©e √† la plus basse.


**Bonus**

a. Repr√©senter grahiquement le lien entre les notes utilisateurs et les notes des critiques.

b. Calculer le coefficient de corr√©lation entre les notes utilisateurs et les notes des critiques. Attention, les `NA` pourraient vous poser des probl√®mes mais avec `use = "complete.obs"` dans la fonction cela devrait fonctionner.



## TP Formation

Compl√©tez les exercices suivants en utilisant. Cr√©ez les vecteurs demand√©s et r√©pondez aux questions en s√©lectionnant les √©l√©ments appropri√©s dans les vecteurs.

### Cr√©ation de vecteur

1. Cr√©er un vecteur appel√© "nombres" contenant les chiffres de 1 √† 10.
1. Cr√©er un vecteur appel√© "mois" contenant les noms des mois de l'ann√©e.
1. Cr√©er un vecteur appel√© "notes" contenant les notes [8, 12, 15, 17, 20].
1. Cr√©er un vecteur appel√© "contrats" contenant les contrat "CDI", "CDD", "Alternance", "Int√©rim".
1. Cr√©er un vecteur appel√© "voyelles" contenant les lettres "a", "e", "i", "o", et "u".

### Manipulation de vecteur


1. S√©lectionner la premi√®re voyelle du vecteur.
1. S√©lectionner la derni√®re voyelle du vecteur.
1. S√©lectionner les deux premi√®res voyelles du vecteur.
1. S√©lectionner toutes les voyelles du vecteur sauf la derni√®re.
1. S√©lectionnez les deux premi√®res notes du vecteur "notes" et cr√©ez un nouveau vecteur avec ces notes en utilisant.
1. S√©lectionner les √©l√©ments du vecteur "nombres" qui sont sup√©rieurs ou √©gaux √† 5 en utilisant la notation.
1. S√©lectionner les voyelles "e" et "o" du vecteur "voyelles" en utilisant la notation.
1. Cr√©er un vecteur appel√© "t1"  √† partir de "mois" contenant les mois du premier trimestre (janvier, f√©vrier, mars).
1. S√©lectionner les contrats "CDI" et "Int√©rim" du vecteur "contrats" en utilisant la notation `[ ]`.


### Simulation de vecteur

La fonction `sample()` permet de g√©n√©rer un √©chantillon al√©atoire √† partir d'une liste de modalit√©s

```{r}
sample(x = c("football","basket","tennis"),
       size = 10, replace = TRUE)
```

1. Cr√©er un vecteur appel√© "sample_contrat" avec un √©chantillonnage d'une centaine de contrat tir√© au sort dans le vecteur "contrats".
1. Cr√©er un vecteur appel√© "sample_age" avec une centaine d'√¢ge tir√© au sort entre 17 et 70 ans.
1. Cr√©er un vecteur appel√© "sample_genre" avec un √©chantillonnage d'une centaine de genre tir√© au sort parmi "homme", "femme" o√π la probabilit√© de tomber sur un homme est de 35%.


### Statistique sur les vecteurs

1. Calculer la moyenne d'√¢ge.
1. Calculer l'√¢ge minimum.
1. Calculer l'√¢ge maximum.
1. Calculer l'√¢ge m√©dian.
1. Calculer la variance de l'√¢ge.
1. Calculer l'√©cart-type de l'√¢ge.
1. Calculer les quantiles de l'√¢ge.
1. Compter la r√©partition du nombre de contrat.
1. Compter la r√©partition du nombre de genre en pourcentage.

Simulation de loi statistique :

La fonction `runif()` permet de simuler des √©chantillons al√©atoires selon une loi uniforme.

```{r}
test  = runif(n = 1000, min = 0, max = 5)
hist(test)
```

1. Cr√©er un vecteur appel√© "sample_anciennete" avec une centaine d'anciennete en mois bas√©e sur une loi uniforme de 0 √† 120.
1. Modifier ce vecteur pour obtenir des mois entier avec la fonction `truncate()`
1. Construire un histogramme avec la fonction `hist()`.

La fonction `rnorm()` permet de simuler des √©chantillons al√©atoires selon une loi normale o√π l'argument `mean` est la moyenne th√©orique.

```{r}
test  = rnorm(n = 1000, mean = 50)
hist(test)
```

1. Cr√©er un vecteur appel√© "sample_salaire" avec une centaine de salaire bas√©e sur une loi normale avec  une moyenne th√©orique de 1700 ‚Ç¨
1. Calculer le salaire moyen.
1. Calculer le salaire m√©dian.
1. Calculer l'√©cart-type.
1. Calculer la masse salariale.
1. Calculer les d√©ciles de la distribution des salaires.
1. Modifier ce vecteur pour obtenir des salaire avec une d√©cimale disponible avec la fonction `round`()`
1. Construire un histogramme avec la fonction `hist()`.

### Repr√©sentation graphique

1. Construire un diagramme en barre de la r√©partition du genre avec la fonction `barplot()`.
1. Construire un diagramme circulaire de la r√©partition des contrats avec la fonction `pie()`.
1. Construire une bo√Æte √† moustache de la distribution du salaire avec la fonction `boxplot()`.
1. Construire des bo√Ætes √† moustache de la distribution du salaire en fonction du genre.
1. Construire une nuage de points du salaire en fonction de l'anciennet√© avec la fonction `plot()`.

### Construire un dataframe 

La fonction `data.frame()` permet de cr√©er un tableau √† partir de vecteur **de m√™me longueur**. 

```{r}
a <- c(1,2,3)
b <- c("Luca","Madeleine","Fran√ßois")
df <- data.frame(a,b)
df
```
1. Construire un data frame appel√© "df" √† partir des vecteurs `sample_genre` `sample_anciennete`, `sample_contrat`, `sample_age` et `sample_salaire`.
1. Compter le nombre de lignes avec la fonction `nrow()`.
1. Compter le nombre de colonnes avec la fonction `ncol()`.
1. Afficher les 3 premi√®res lignes avec la fonction `head()`.
1. Afficher un r√©sum√© des donn√©es avec la fonction `summary()`.
1. Afficher le nom des colonnnes avec la fonction `colnames()`.
1. Renommer les colonnes en supprimant le pr√©fixe "sample_".
1. Supprimer la colonne "anciennete"
1. Cr√©er une colonne appel√© "salaire_net" qui correspond √† 80% du salaire brut.
1. Cr√©er une colonne appel√© "anciennete_annee" qui correspond au nombre d'ann√©e d'anciennet√©.
1. Avec la fonction `cut()`, cr√©er une colonne appel√© "tranche_salaire" qui est un d√©coupage en tranche de 500‚Ç¨.
1. Cr√©er une colonne appel√© "anciennete_annee" qui correspond au nombre d'ann√©e d'anciennet√©.
1. Avec la fonction `ifelse()`, cr√©er une colonne appel√© "prime" qui prend la valeur "oui" si le salari√© √† plus de 3 ans d'anciennet√©, sinon "non".
1. Exporter ce data frame en fichier *df.csv* avec la fonction `write.csv()`.
1. Supprimer l'objet "df" avec la fonction `rm()`.
1. Importer le fichier *df.csv* dans un objet appel√© "df" avec la fonction `read_csv()`.

### Manipuler un dataframe 

Pour r√©pondre √† ces questions, utilisez la syntaxe `[ ]`.

1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les deux premi√®res colonnes.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement la colonne "contrat" et "age".
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement toutes les colonnes sauf la derni√®re.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les 25 premi√®res lignes.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les lignes 10 √† 20 et 50 √† 100.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les 25 premi√®res lignes et les colonnes "genre", "age", "contrat" dans ce sens.

M√™me exercice mais avec le package `dplyr` avec ses fonctions `slice()` et `select()`.

### Filtrer un dataframe 

Pour r√©pondre √† ces questions, utilisez la fonction `subset()`.

1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes de plus de 40 ans.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes de 30 ans plus.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes en CDD.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes en CDD qui gagne plus de 1500‚Ç¨.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes en CDD qui gagne plus de 1500‚Ç¨.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes qui gagne entre 1500 et 1900‚Ç¨.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement toutes les personnes sauf celles en CDI
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement toutes les personnes sauf celles de 50 ans.
1. Cr√©er un nouveau data frame appel√© "dfTest" avec uniquement les personnes en CDD OU en alternance

M√™me exercice mais avec le package `dplyr` et sa foncton `filter()`.

### Trier un dataframe 

Pour r√©pondre √† ces questions, utilisez le package `dplyr` et sa foncton `arrange()`.

1. Cr√©er un nouveau data frame appel√© "dfTest" tri√© par √¢ge croissant.
1. Cr√©er un nouveau data frame appel√© "dfTest" tri√© par salaire d√©croissant.
1. Cr√©er un nouveau data frame appel√© "dfTest" tri√© par contrat puis par salaire d√©croissant.
1. Cr√©er un nouveau data frame appel√© "dfTest" tri√© par √¢ge d√©croissant puis par salaire d√©croissant.
1. Cr√©er un nouveau data frame appel√© "dfTest" tri√© par genre, puis √¢ge croissant puis par salaire d√©croissant.

### Agr√©ger les donn√©es

Pour r√©pondre √† ces questions, utilisez le package `dplyr` et ses fonction `group_by()` et ` summarise()`.

1. Cr√©er un nouveau data frame appel√© "dfAgg" avec l'√¢ge moyen par type de contrat.
1. Cr√©er un nouveau data frame appel√© "dfAgg" avec le salaire moyen ET l'anciennet√© moyenne par type de genre.
1. Cr√©er un nouveau data frame appel√© "dfAgg" avec le salaire moyen par type de contrat ET le genre.
1. Cr√©er un nouveau data frame appel√© "dfAgg" avec le salaire min/max ET l'anciennet√© min/max par type contrat.
1. Cr√©er un nouveau data frame appel√© "dfAgg" avec le nombre de salari√© par genre ET type de contrat.
1. Cr√©er un nouveau data frame appel√© "dfAgg" avec le nombre de salari√© par genre.


### L'usage du pipe %>% 

Pour r√©pondre √† ces questions, utilisez le raccourci `%>%`.

```{r, echo=FALSE}
library(dplyr)
```
```{r}
a <- c("CDD","CDI","Alternance","Int√©rim")
a %>% 
  sample(size = 10, replace = TRUE) %>% 
  table() 
```

1. Cr√©er un nouveau data frame appel√© "dfTest" avec les personnes de plus de 30 ans.
1. Calculer ensuite le salaire moyen et l'anciennet√© moyenne selon le genre et le type de contrat.
1. Trier ensuite par moyenne de salaire d√©croissante.
1. Filtrer ensuite sur les salaire moyens de plus de 1500‚Ç¨.
1. Exporter cet objet R avec la fonction `save()`.

